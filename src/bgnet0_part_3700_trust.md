# 信任用户数据

> "你永远不知道谁是值得相信的。。。“
>
> --Gregor Ivanovich, _Sneakers_

当你的服务器从因特网上的某人那里收到数据时，要首先天然的相信他们发送的数据不是善意的。

因特网上有很多不怀好意的人，你必须采取措施防止它们发送的数据使你的服务器进程崩溃，或者更糟的是，让它们访问你的服务器机器数据本身。在本章中，我们将对用户试图发送恶意数据可能产生的一些问题进行一些概念上的学习。

总体来说，有两个大的原则:
* _像恶棍一样思考_。在什么情况下会有人向你发送恶意代码让你的程序崩溃或者产生意想不到的结果？
  
* 不要相信从远端来的 **任何东西**。 不要相信它会是一个合理的长度。不要相信它会包含合法的数据。

## 缓冲区溢出/超限

这主要会影响一些内存不安全的语言比如C或者C++。

基本思路是:
1. 你的程序申请了一个固定长度的内存以供程序使用。
   
2. 你的程序通过网络连接将一些数据读入该内存区域。
   
3. 攻击者发送的数据超过了该内存区域的容量，并且数据经过精心构造以包含了有效负载。
   
4. 你的程序单纯地写入攻击者的数据，填充自己的内存区域，然后溢出到内存中的任何地方。
   
5. 根据攻击者代码的编写方式，攻击者可以覆盖堆栈上的返回地址值，从而导致函数返回到攻击者的攻击代码并运行它。攻击代码可能从系统安装病毒或更改系统以允许远程访问。

现代操作系统试图通过使内存的堆栈和堆区域不可执行，以及内存的代码区域不可写来减轻这种影响。作为一名C语言编开发人员，在代码中你需要正确执行边界检查，并且永远不会写入非允许的内存。

## 注入攻击

在这些攻击中，你使用用户提供给你的一些带有数据的命令。然后直接运行这个命令。一些恶意用户会向你提供引导运行另一个命令的数据。

### 系统命令

在许多语言中，都有一个允许你通过shell运行命令的功能。例如，在Python中，你可以运行`ls`命令来获得如下的目录列表:

``` {.py}
import os

os.system("ls")
```

假设你编写了一个接用户发送的数据的服务器程序。用户按照自己想要的选择的功能，将会选择发送`1`, `2`或`3`作为数据。你在你的服务器上运行类似下面的代码:

``` {.py}
os.system("mycommand " + user_input)
```

所以，如果用户发送`2`，它将按预期运行`mycommand 2`并且将输出返回给用户。

为了安全起见，`mycommand`程序会验证唯一允许的输入是`1`, `2` 或 `3` ，如果对方发送了其他内容，则返回错误。

那么我们安全了吗？并没有，你猜怎么着？用户可以传入类似如下输入:

``` {.default}
1; cat /etc/passwd
```
这将会导致服务器端执行如下内容:

``` {.default}
mycommand 1; cat /etc/passwd
```

分号是bash中的命令分隔符。这将导致`mycommand`程序执行，然后会继续执行显示Unix密码文件内容的命令。为了安全起见，输入中的所有特殊字符都需要被剥离或进行转义，这样shell就不会解释它们。

### SQL 命令

还有一种类似的攻击称为SQL注入，在这种攻击中，没有任何防范的SQL查询检查可以允许恶意用户执行任意SQL查询。假设你在Python中构建一个这样的SQL查询，我们从网络上通过`username`获取信息:

``` {.py}
q = f"SELECT * FROM users WHERE name = '{username}'
```

所以，当我输入`Alice` 作为用户名时，我们可以有如下合法的查询语句:

``` {.sql}
SELECT * FROM users WHERE name = 'Alice'
```

接着，我会运行它，没有任何问题。不过，让我们 _像恶棍一样思考下_。如果我们输入这些会怎样:

``` {.sql}
Alice' or 1=1 --
```

现在我们会得到: 

``` {.sql}
SELECT * FROM users WHERE name = 'Alice' or 1=1 -- '
```

`--` 是SQL中的注释符号，现在我们已经组合了一个查询，它会显示所有用户信息，而不仅仅是Alice的信息。 

不仅如此，一些数据库的实现还可能支持`;`命令分隔符。如果是这样，攻击者可以这样做: 

``` {.sql}
Alice'; SELECT * FROM passwords --
```

现在我们得到了如下的命令: 

``` {.sql}
SELECT * FROM users WHERE name = 'Alice'; SELECT * FROM passwords -- '
```

现在我们从输出中得到了`passwords`表所有信息。 

要避免这种陷阱，需要使用 _参数化查询生成器_ 。它是SQL库中的一部分，它可以使得任何用户输入的查询都足够安全。 永远不要尝试自己构建SQL字符串。

### 跨站脚本

这是一个会在HTML/JS中发生的情况。 

假设你有一个接受用户评论的表单，然后服务器将该评论附加到web页面。所以当用户输入:

``` {.default}
This site has significant problems. I feel uncomfortable using it.

Love, FriendlyTroll
```

不过它在最后附加了如下一段代码:

``` {.html}
LOL
<script>alert("Pwnd!")</script>
```

现在，每个人在查看评论时都会看到这个警告框!

这是一个无伤大雅的例子,这里的JavaScript代码还可以是其他任何东西，并可以在远程站点上执行(这意味着它可以作为该域执行API调用和获取)。它还可以重写页面，以便登录/密码输入将该信息提交给攻击者的网站。
> "It would be bad."
>
> Egon Spengler, _Ghostbusters_

大多数面向html的库都提供了一个函数来对字符串进行转义，这样浏览器就直接显示它们而不是解释它们(例如，将所有的`<`替换为`&gt;`等等)。

在浏览器上显示任何用户生成的数据之前，一定要先通过这样的函数来运行它。
 
## 思考题

* 总体来说，无条件信任用户输入的问题是什么?

* 为什么缓冲区溢出在Python、Go或Rust等语言中不像在C语言中那样严重?
