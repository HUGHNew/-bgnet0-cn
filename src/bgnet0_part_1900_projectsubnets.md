# 实战项目: 计算和发现子网

为了准备我们的后续项目，即寻找跨网络的路由，我们需要先做一些工作来弄清楚IP地址、子网掩码和子网是如何协同工作的。

在本项目中，我们将会对前面几章学习到的内容进行一些练习，我们将会：
* 编写函数将点-数字形式的IP地址转换为单个32位值，然后再转换回来。

* 编写一个函数，将斜杠形式表示的子网掩码转换为表示该掩码的单个32位值。

* 编写一个函数来查看两个IP地址是否在同一子网上。
  

## 限制

本项目中 **不能** 使用：

* 任何`socket`模块中的函数。
* 任何`struct`模块中的函数。
* 任何`netaddr`模块中的函数。
* 函数`.to_bytes()` 和 `.from_bytes()`。

目的是为了你自己动手写这些具体的位操作函数。

## 最终目标

[fls[请获取这个ZIP文件中的框架代码和其他相关文件|netfuncs/netfuncs.zip]]。你需要填写其中空缺的部分。

实现`netfuncs.py`中的下列函数:

* `ipv4_to_value(ipv4_addr)`
* `value_to_ipv4(addr)`
* `get_subnet_mask_value(slash)`
* `ips_same_subnet(ip1, ip2, slash)`
* `get_network(ip_value, netmask)`
* `find_router_for_ip(routers, ip)`

在文件中每个的文档字符串中都有函数作用的描述，这里要特别注意的是所示示例中的输入和输出 _类型_。请注意，这里面没有函数需要多于5到15行，如果你在实现的过程中，函数的大小大于这个值，大概率你没有走在正确的道路上。

## 测试

我鼓励你一次 _实现一个函数_，并在开始实现下一个函数之前，通过使用自己的示例数据来对其进行测试。你可以把将验证调用加到函数中，这样可以帮你验证你正在做的是正确的。还可以注释中的输入和输出作为测试条件。

在`netfuncs.py` 中有叫做`my_tests()`的函数，如果你取消它的注释，那么它将作为默认的主函数入口执行。如果你取消注释掉`my_tests()`，你可以按照下面的方法运行程序:

``` {.sh}
python netfuncs.py
```

并且查看从该函数的输出。请确保在你提交程序之前注释掉了`my_tests()`，如同下一节将要说明的一样。

## 运行程序

你将会像如下方式一样运行该程序:

``` {.sh}
python netfuncs.py example1.json
```

它从`example1.json`阅读JSON数据并且在从执行你的函数中的很多部分。输出包含在`example1_output.txt`文件中，如果所有事情都正确的话，那么输出会如下所示:

``` {.default}
Routers:
     10.34.166.1: netmask 255.255.255.0: network 10.34.166.0
     10.34.194.1: netmask 255.255.255.0: network 10.34.194.0
     10.34.209.1: netmask 255.255.255.0: network 10.34.209.0
     10.34.250.1: netmask 255.255.255.0: network 10.34.250.0
      10.34.46.1: netmask 255.255.255.0: network 10.34.46.0
      10.34.52.1: netmask 255.255.255.0: network 10.34.52.0
      10.34.53.1: netmask 255.255.255.0: network 10.34.53.0
      10.34.79.1: netmask 255.255.255.0: network 10.34.79.0
      10.34.91.1: netmask 255.255.255.0: network 10.34.91.0
      10.34.98.1: netmask 255.255.255.0: network 10.34.98.0

IP Pairs:
   10.34.194.188    10.34.91.252: different subnets
   10.34.209.189    10.34.91.120: different subnets
   10.34.209.229    10.34.166.26: different subnets
   10.34.250.213    10.34.91.184: different subnets
   10.34.250.228    10.34.52.119: different subnets
   10.34.250.234     10.34.46.73: different subnets
     10.34.46.25   10.34.166.228: different subnets
    10.34.52.118     10.34.91.55: different subnets
    10.34.52.158     10.34.166.1: different subnets
    10.34.52.187    10.34.52.244: same subnet
     10.34.52.23    10.34.46.130: different subnets
     10.34.52.60    10.34.46.125: different subnets
    10.34.79.218     10.34.79.58: same subnet
     10.34.79.81    10.34.46.142: different subnets
     10.34.79.99    10.34.46.205: different subnets
    10.34.91.205    10.34.53.190: different subnets
     10.34.91.68    10.34.79.122: different subnets
     10.34.91.97    10.34.46.255: different subnets
    10.34.98.184     10.34.209.6: different subnets
     10.34.98.33   10.34.166.170: different subnets

Routers and corresponding IPs:
     10.34.166.1: ['10.34.166.1', '10.34.166.170', '10.34.166.228', '10.34.166.26']
     10.34.194.1: ['10.34.194.188']
     10.34.209.1: ['10.34.209.189', '10.34.209.229', '10.34.209.6']
     10.34.250.1: ['10.34.250.213', '10.34.250.228', '10.34.250.234']
      10.34.46.1: ['10.34.46.125', '10.34.46.130', '10.34.46.142', '10.34.46.205', '10.34.46.25', '10.34.46.255', '10.34.46.73']
      10.34.52.1: ['10.34.52.118', '10.34.52.119', '10.34.52.158', '10.34.52.187', '10.34.52.23', '10.34.52.244', '10.34.52.60']
      10.34.53.1: ['10.34.53.190']
      10.34.79.1: ['10.34.79.122', '10.34.79.218', '10.34.79.58', '10.34.79.81', '10.34.79.99']
      10.34.91.1: ['10.34.91.120', '10.34.91.184', '10.34.91.205', '10.34.91.252', '10.34.91.55', '10.34.91.68', '10.34.91.97']
      10.34.98.1: ['10.34.98.184', '10.34.98.33']
```

如果你得到了不同的输出，请尝试查看代码，看看哪些函数使用了错误的输出。然后在`my_tests()`函数中对它们进行更详细的测试。

<!--
新的计分表

每一项都是5分，一共100分

ipv4_to_value(): 正确返回一个数值类型
value_to_ipv4(): 返回正确的字符串
get_subnet_mask_value(): 使用位操作函数来执行掩码操作
ipv4_to_value(): 成功地将任何点-数格式的IP地址转换为对应的数值，表示该IP被打包成一个4字节32位整数。
value_to_ipv4(): 成功地将表示IP的单个值转换为4字节32位整数，并将其转换为点-数格式的字符串。
value_to_ipv4(): 字符串中任何数字都没有前导零。
value_to_ipv4(): 没有任何多余的补齐--在输出中字符串只有点和数字。
get_subnet_mask_value(): 正确返回斜杠表示法表示的子网掩码转换的整数。
get_subnet_mask_value(): 处理普通斜杠符号，如"/16"和IP/斜杠符号，如"198.51.100.12/22"。
ips_same_subnet(): 如果两个输入在同一子网上，则返回True。
ips_same_subnet(): 调用 get_subnet_mask_value() 函数来获取子网掩码。
ips_same_subnet(): 调用 ipv4_to_value() 来获取IP地址。
ips_same_subnet(): 执行适当的位操作以确定IP地址是否在同一子网上。
get_network(): 以整数形式返回IP地址的网络部分。
get_network(): 使用正确的位运算算法得到结果。
find_router_for_ip(): 正确找到与给定IP在同一子网上的路由。
find_router_for_ip(): 以点-数字符串的形式返回路由IP。
find_router_for_ip(): 如果在给定IP的同一子网中没有找到路由，则返回None。
find_router_for_ip(): 调用 ips_same_subnet() 函数来进行判断。
不要修改任何写有“do-not-modify”之下的代码。

-->