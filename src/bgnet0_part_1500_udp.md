# 用户数据报协议（UDP）

如果你是一个喜欢保持事物整洁并且乐观的人，UDP非常适合你。它是一个互联网上近乎极致的轻量级数据传输协议。发送端发射UDP数据包并且祈祷它们回达到对方，也许它们会，也许有人用挖土机挖穿了光缆，或者有宇宙射线干扰，又或者路由器过于拥塞或愤怒，直接将其丢弃，或者各种随机原因。它生活在互联网传输数据的边界!几乎所有令人愉快和可靠的TCP保证都消失了!

## UDP目标

* 提供一种将无差错的将数据从一台计算机发送到另一台计算机的方法。

这就是UDP所有内容。

下面这些都**不是**UDP的目标:

* 保证数据是有序的
* 保证数据不丢失
* 保证数据没有重复

如果需要上面的功能，TCP将会是更好的选择，UDP不提供任何对于数据丢失或者数据乱序的保障，它唯一的保障是 _如果_ 数据抵达，那么该数据是准确的。UDP协议可以提供的是低开销和快速的响应时间，它没有如TCP一般的任何数据包装配或者流量控制或者数据包响应。因此，它的数据报头更加的小。

## 网络栈中的位置

回一下之前说的网络栈:

<!-- 图示: 因特网分层模型 -->
|层级|职责|协议举例|
|:-:|-|-|
|应用层|结构化的应用层数据|HTTP, FTP, TFTP, Telnet, SSH, SMTP, POP, IMAP|
|传输层|数据完整性，数据分割和组装|TCP, UDP|
|网络层|路由|IP, IPv6, ICMP|
|链路层|物理设备，线路上的电信号|Ethernet, PPP, token ring|

正如我们看到的，UDP位于传输层，在其之下的IP层负责路由，在其之上的应用层享受所有UDP应该提供的好处，虽然不是很多。

## UDP 端口

类似于TCP， UDP使用端口。实际上，您可以让一个TCP程序与另一个UDP程序使用相同的端口号。 IP协议使用IP地址来标示主机。但是当我们缩小到主机范围，端口号是操作系统用来将数据发送到正确进程的媒介。举例来说，IP地址就像是街道号，端口号就像是该街道地址上的公寓门牌号。

## UDP 总览

UDP 是 _无连接状态_ 的，前面介绍过，TCP基于数据包转发网络来保证两个计算机之间建立的连接是可靠的。UDP并不保证如此。客户端向IP地址和端口发送UDP数据报，IP协议负责将其路由到指定地址，并且接收端计算机将数据报发送到绑定到规定端口的程序上。

在这里，没有任何连接，只有单独的基于单个包的机制。当一个数据包到达时，接收端可以分辨出该数据包是从哪个IP和端口而来，基于此，接收端可以发送一个回复。

## 数据完整性

在网络传输中，有很多可能会导致错误的事情，数据可能乱序到达，可能损坏，可能重复，甚至根本到达不了。 UDP几乎没有任何方法可以处理这些意外事件，实际上，它唯一做的就是错误检测。

### 错误检测

在发送一个数据报之前，会根据数据包计算出一个 _校验和_。 校验和的作用和TCP完全一致，除了在这里使用的是UDP的包头，相对于TCP包头，UDP包头十分的简单:

``` {.default}
 0      7 8     15 16    23 24    31  
+--------+--------+--------+--------+ 
|     Source      |   Destination   | 
|      Port       |      Port       | 
+--------+--------+--------+--------+ 
|                 |                 | 
|     Length      |    Checksum     | 
+--------+--------+--------+--------+ 
|                                     
|          data octets ...            
+---------------- ...                 
```

当接收方收到这个数据包的时候，它会根据该数据包计算出校验和，如果两方校验和一致，那么该数据被认为是无差错的。如果他们不一致，那么直接丢弃该数据。

这就是整个过程，接收端甚至不知道有一些数据是发送给它的，数据包只是消失在网络中。校验和是一个将所有UDP包头和有效负载数据以及所涉及的IP地址作为参数，计算出来的一个16位数字。

这和TCP中校验和工作方式一样。（Jon Postel为TCP和UDP编写了第一个RFC，所以它们使用相同的算法并不奇怪。）在本周的项目中，将会详细介绍如何计算校验和，只需要将TCP包头替换成UDP包头即可。

## 不分片最大负载

虽然这在后面才会详细介绍，但是底层协议可以决定是否将UDP数据包分割位更小的数据包。甚至也许在互联网的某一部分，只能处理发送一定大小的数据包通过。我们把这种将UDP数据包分割为多个IP数据包的过程叫做“分片”。

一个线路中能通过的数据包的最大大小叫做MTU（最大传输单元），在因特网（IPv4）上能传输的最小可能的MTU大小是576字节，而最大的IP头大小是60字节，UDP头是8字节。所以能保证最大不会被分片的负载大小是576-60-8 = 508字节[如果数据是通过一个VPN发送的，能发送的最大负载大小要小于这个数，在这里，我们先不考虑这个情况。]。由于有时IP头的大小小于60字节，所以很多发送源会说发送上限是512字节。分片有什么坏处么？有些路由器会丢弃分片的UDP数据，所以保持发送的数据小于最小MTU常常是一个好主意。

## 用在何处？

如果UDP可能在任意时候丢失数据包，那么为什么我们会使用它？因为它对性能提升是显著的，所以这是一个权衡。

下面是一些UDP会被用到的场景:
1. 如果你对是否丢失数据包并不在意，比如，你正在传送的是声音，视频或者甚至是游戏帧信息，丢失一些数据包是不会影响整体的，最多只是流将暂时中断，然后在下一个数据包到达时继续。这是最常见的使用模式。多玩家高帧率游戏一般使用UDP来做逐帧更新，同时也在低带宽时使用TCP来发送玩家聊天信息或者用户装备变化。

2. 如果传输过程不能忍受数据包丢失，还是可以基于UDP来实现另一种协议，TFTP（简单文件传输协议）这样一种协议。该协议会在每个数据包中放置一个序列号，并且只会在对方回复一个TFTP ACK数据包之后再发送下一个数据包。由于需要等待到ACK才能发送下一个数据包，所以该协议速度并不快，不过这是一个非常容易实现的协议。这是一种比较少见到的协议，TFTP一般用在没有操作系统的无盘计算机上。他们在启动时通过网络传输操作系统，并且利用一个预置的网络协议栈来使其可以被实现。而实现Ethernet/IP/UDP协议栈要远比实现Ethernet/IP/TCP简单。

3. 如果，你希望在没有多个TCP连接的情况下对不同的数据“流”进行多路复用，这时就可以用标识符标记每个UDP数据包，以便它们在到达时都进入正确的位置。

4. UDP使得有机会进行提前处理，你甚至又可能在数据包3还未到达的情况下预先处理数据包4。

5. 其他合适的情况。

## UDP （数据报）套接字

对于UDP套接字，它和TCP套接字有如下很多不同点:
* 由于没有“连接”，调用者将不需要调用`listen()`, `connect()`, `accept()`, `send()`，或者`recv()`。
* 调用 `sendto()`来发送UDP数据。
* 调用 `recvfrom()`来接收UDP数据。

### 服务端程序

通用的服务端程序时创建一个新的类型为`SOCK_DGRAM`的套接字，也就是数据报/UDP套接字。（在TCP中，使用的是默认的`SOCK_STREAM` 类型套接字。）接着服务器端调用 `bind()` 将其绑定到一个端口上，该端口是客户端将要发送数据包的地方。在此之后，服务器端可以循环接收数据或者发送数据。

当服务器端接收到数据时，`recvfrom()` 将返回发送数据的主机和端口。这可以用于回复，以将数据发送回发送方。下面是服务器端程序的例子:

``` {.py}
# UDP Server

import sys
import socket

# Parse command line
try:
    port = int(sys.argv[1])
except:
    print("usage: udpserver.py port", file=sys.stderr)
    sys.exit(1)

# Make new UDP (datagram) socket
s = socket.socket(type=socket.SOCK_DGRAM)

# Bind to a port
s.bind(("", port))

# Loop receiving data
while True:
    # Get data
    data, sender = s.recvfrom(4096)
    print(f"Got data from {sender[0]}:{sender[1]}: \"{data.decode()}\"")

    # Send a reply back to the original sender
    s.sendto(f"Got your {len(data)} byte(s) of data!".encode(), sender)
```

### 客户端程序

客户端程序几乎和服务器端程序相同，唯一的不同是客户端不需要使用`bind()`来绑定到特定的端口，它会让操作系统在第一次调用`sendto()`自动选择要绑定的端口。请记住: UDP是不可靠的，所以很有可能发送的数据最终不会到达，如果没有到达对端，再次尝试即可。（不过，如果是在本机运行的话，几乎最终一定会达到。）

下面是可以和上面服务器程序通信的客户端程序:

``` {.py}
# UDP Client

import socket
import sys

# Parse command line
try:
    server = sys.argv[1]
    port = int(sys.argv[2])
    message = sys.argv[3]
except:
    print("usage: udpclient.py server port message", file=sys.stderr)
    sys.exit(1)

# Make new UDP (datagram) socket
s = socket.socket(type=socket.SOCK_DGRAM)

# Send data to the server
print("Sending message...")
s.sendto(message.encode(), (server, port))

# Wait for a reply
data, sender = s.recvfrom(4096)
print(f"Got reply: \"{data.decode()}\"")

s.close()
```

## 思考题

* 除了保证数据能够传输到对端，还有什么TCP可以提供但是UDP做到的么？

* 为什么一般都推荐保持发送比较小的UDP数据包？

* 为什么UDP的包头小于TCP的包头？

* 函数`sendto()`需要指定目的地IP地址和端口，为什么TCP的`send()` 函数不需要指定这些参数？

* 为什么UDP相对TCP来说没有那么可靠，人们仍然会使用它呢？
