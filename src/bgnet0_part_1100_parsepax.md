# 数据包解析

在前面我们已经遇到了一些在服务器上接收结构化数据的问题，比如，当你调用 `recv(4096)`，但是你实际上你只接收到了20个字节。或者同样调用`recv(4096)`得到的数据却大于4096个字节，而导致你需要再次调用该函数。

实际上还有更加严重的问题，如果一个服务器给你发送了好几段的数据，你可能只接收到第一或者下一段的一部分，你将会收到一个完整的数据包加上一个部分完整的数据包，这种情况下，你如何能够重构原始数据包呢？

打个比方，如果我需要你从我给你的一大块文本中分离出单独的句子，但你一次只能得到20个字符。你调用`recv(20)` 看到如下的字符串:

``` {.default}
This is a test of th
```

这不是原始完整的句子，此时你还不能将其打印出来，因此，你需要再次调用`recv(20)` :

``` {.default}
This is a test of the emergency broadcas
```

仍然不是一个句子，让我们再次调用:

``` {.default}
This is a test of the emergency broadcast system. This is on
```

看！结果中出现了一个句号，所以我们得到了一个完整的句子。我们以句号为分割符将其打印出来。但是，同时我们也收到了下一句的部分信息！那么，我们怎么才能优雅的处理整个过程呢？

## 你知道怎么能让这事简单点吗?

你知道怎么能让这事简单点吗?如果我们把它抽象出来，然后我们可以使用如下的逻辑:

``` {.py}
while the connection isn't closed:
    sentence = get_next_packet()
    print(sentence)
```

有没有根据这个逻辑发现处理思路呢？一旦我们的代码的逻辑可以从数据流中提取出下一个完整的数据包，我们就可以使用它。如果程序的逻辑足够的完备，那么事实上它可以从数据流中提取出不同类型的数据包,比如:

``` {.py}
packet = get_next_packet()

if packet.type == PLAYER_POSITION:
    set_player_position(packet.player_index, packet.player_position)

elif packet.type == PRIVATE_CHAT:
    display_chat(packet.player_from, packet.message, private=True)
```

这使得无论收到的数据包是不是完整的字节序列都变得容易很多，当然，处理的过程还有很多细节，让我们来思考下如何完成整个过程。

## 将流处理成数据包

使得整个处理逻辑能工作的一个最大的秘密就是:申请一个大的全局缓冲区。
> 一个缓冲区是一片大量字节存储区域的另一种叫法。
> 在Python中，它可以是一个字节字符串，也就是可以方便的从`recv()`取得的返回值。

这个缓冲区将保存到目前为止你收到的字节，你需要检查缓冲区来确认它是否保存了一个完整的数据包。如果在缓冲区中已经有了一个完整的数据包，程序需要将其返回（以字节字符串或者其他处理过的形式）。并且，非常重要的是，需要在缓冲区中删除该数据包。如若不然，你需要再次调用`recv()`函数直到缓冲区中拥有一个完整的数据包。

``` {.py}
packet_buffer = b''

def get_next_packet(s):
    global packet_buffer

    # Now we can use the global version in here
```

不然，Python会在函数中创建一个新的本地变量而掩盖了全局的那个变量。

## 再来看看之前的“句子”示例

让我们再来研究下本章开头的句子的示例，我们将会调用`get_sentence()`函数，它的作用是收到所有数据并且查看其中是否有句号，一开始我们拥有的是:

``` {.default}
  
```

什么也没有，因为我们还没收到数据，理所当然，其中也不会有句号，所以我们也不会得到一个完整的句子。接下来，我们需要调用`recv(20)`来获取更多的字节:

``` {.default}
This is a test of th
```

依然还没以欧句号，再次调用`recv(20)`:

``` {.default}
This is a test of the emergency broadcas
```

还是没有句号，再次调用`recv(20)`:

``` {.default}
This is a test of the emergency broadcast system. This is on
```

阿，终于有了一个句号！所以我们需要做以下两件事情:
1. 将句子提取出来，这样我们可以返回该结果，并且
2. 将提取出来的句子从缓冲区中删除。

在上述两步完成之后，第一句应该已经从缓冲区中消失，并且:

``` {.default}
This is on
```

程序将会返回第一句话"This is a test of the emergency broadcast system."，而我们调用的`get_sentence()`函数可以打印出该句话。

接下来，让我们再次调用 `get_sentence()` ,在`get_sentence()`中，我们会再一次的去查看缓冲区（注意，这里的缓冲区是全局的，所以在其中仍然会有自从上次调用者之后剩下的数据。）

``` {.default}
This is on
```

目前，这个剩余的数据中并没有句号，所以我们将会再次调用 `recv(20)` ,不过这次，我们只能取回10个字节。

``` {.default}
This is only a test.
```

而这已经是一个完整的句子了，我们将其从缓冲区中取出，导致缓冲区清空，程序返回至调用方等待输出。

### 如果一次性收到了多句话会怎样?

如果当我调用 `recv(20)`时得到了如下的结果:

``` {.default}
Part 1. Part 2. Part
````

你看，这仍然能工作，`get_sentence()` 函数可以看到数据中的第一个句号，继而从缓冲区中剥离第一句话，从而我们得到:

``` {.default}
Part 2. Part
```

此时会返回 `Part 1.`。

下一次继续调用 `get_sentence()`时，和之前一样，它做的第一件事是去查看缓冲区中是否还有一个完整的句子，在发现确实仍然还有之后，将其剥离出来。

``` {.default}
Part
```

继而返回`Part 2.`。当下次再次调用`get_sentence()`时，函数发现在缓冲区中没有了句号，所以，目前已经没有完整的句子了，函数会继续调用 `recv(20)`以取得更多的数据。

``` {.default}
Part 3. Part 4. Part 5.
```

现在，重新组成了完整的句子，按照之前的逻辑，将其前面的数据从缓冲区剥离:

``` {.default}
Part 4. Part 5.
```

继续返回`Part 3`返回给调用者，继而复始。

## 进一步的优化

总体来说，你可以将此抽象为一个充满数据的管道，当管道中充满了数据包时，程序会从缓冲区的前端提取出这些数据并且返回。但是如果没有足够的数据的话，管道会接收更多的数据置于缓冲区的后部，并且保持监测是否已经收到了一个完整的数据包，如下时这个过程的伪代码:

``` {.py}
global buffer = b''    # 空字节字符串

function get_packet():
    while True:
        if 缓冲区已经收到一个完整数据包
           提取数据包数据
           从缓冲区前部提取出数据
           返回该数据包数据

        接收更多的数据

        if 收到的数据是0字节
           返回连接已关闭的标示
        
        将接收到的数据置于缓冲区后部
```

在Python中，你可以分割缓冲区以从前端删除数据包数据，举例来说，如果你知道一包数据是12字节，你可以用以下代码将其删除:

## 思考题

* 从编程的角度思考下从数据包中抽取出数据流的好处是什么。

