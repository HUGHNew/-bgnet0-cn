# 传输控制协议(TCP)

如果有人开挖掘机挖断了光纤，网络上的数据包可能会丢失。（通过将船锚拖入海底网络电缆，整个国家都离线了!）软件错误、电脑死机和路由器故障都可能导致问题。但是用户不需要考虑这个，用户只需要一个部件来处理所有这些，然后让用户知道何时数据是完整的、完备的和有序的。

TCP就是这个部件，它会关心数据包丢失的问题而对用户完全透明，当它确信自己接收到了完整的数据包时，它会将数据包返回给我们。

在本节中，将会学习到:
* TCP的整体目标
* 在网络占中，它位于哪一层
* 回顾TCP中端口的概念
* TCP如何建立，使用和关闭连接
* 数据完整性机制
  * 维护数据包顺序
  * 监测错误
* 流量控制 -- 接收端如何避免不知所措
* 拥塞控制 -- 发送端如何防止网络过载
  
TCP是一个非常复杂的主题，我们在这里只略读其中的重点。如果你想更深入的学习，应该阅读的书籍是 _TCP/IP 图解卷一_ (W. Richard Stevens)。

## TCP的目标

* 提供一个可靠的通信机制
* 在数据包交换网络中模拟出类似电路连接的效果
* 流量控制
* 拥塞控制
* 支持带外数据

## 网络协议栈中的位置

先来回忆下网络栈中的层级:

<!-- 图示: 因特网分层模型 -->
|层级|职责|协议举例|
|:-:|-|-|
|应用层|结构化的应用层数据|HTTP, FTP, TFTP, Telnet, SSH, SMTP, POP, IMAP|
|传输层|数据完整性，数据分割和组装|TCP, UDP|
|网络层|路由|IP, IPv6, ICMP|
|链路层|物理设备，线路上的电信号|Ethernet, PPP, token ring|

你可以看到，TCP位于传输层，它底下的IP层负责路由，而它上面的应用层享受所有TCP所带来的好处。这就是为什么当我们编写HTTP客户端和服务器程序时，我们完全不需要担心数据完整性。我们会让TCP全权处理这些细节！

## TCP端口

回忆下当我们使用TCP的时候，我们需要指定一个连接的端口号，即使是本端的客户端，操作系统也会自动赋予一个本地的端口号（如果我们没有主动调用`bind()`函数）。IP协议使用IP地址来表示主机。

但是，一旦连接到该主机上，操作系统就会使用端口号将数据传递给正确的进程。打个比方来说，IP地址就像街道地址，端口号就像街道地址上面的公寓门牌号。

## TCP综述

一个TCP在连接中主要会做三件事情:
1. 建立连接
2. 传输数据
3. 关闭连接
   
这上面的每一项都包括在客户端和服务器程序间传输特殊的非用户数据数据包，我们将会详细学习这些特殊类型的数据包，比如SYN, SYN-ACK, ACK, 和 FIN.

### 建立连接

这就是非常著名的“三次握手”，由于任何数据包都可能在传输过程中丢，TCP在连接建立传输数据的连接成功之前会使用额外的步骤保证两端都建立上了连接。

1. 客户端发送一个SYN（同步）数据包给服务器。
2. 服务回复一个SYN-ACK（同步认证）数据包给客户端。
3. 客户端回复一个ACK（认证）数据包给服务器。

如果这三步中，如果在一定时间内没有收到回复，该数据包会重新发送。

### 发送数据

TCP接收数据流并将其分割成数据块，每一块数据都拥有一个和其关联的TCP报头，接着整个数据包会通过IP层将其发送出去。这个数据报头加上数据块被称之为TCP _片段_ 。（我们将交替使用“TCP数据包”和“TCP段”，但段更正确。）

当TCP发送一个段时，它期望该数据的接收方响应一个确认消息，称为ACK。如果TCP没有收到这个ACK，它会认为发生了某些错误并且需要重传该段。每个段消息都会被编号所以即使它们没有按照顺序到达，TCP仍然可以将它们按照正确的顺序放回。

### 关闭连接

当某一边想要关闭连接时，它将会发送FIN（结束[_sic_]）数据包，远端此时一般会回复一个ACK和一个自己的FIN数据包，接着，本地端会以另外一个ACK来彻底关闭连接。在一些操作系统中，如果一个主机在还有未读数据的时候关闭了连接，它会发送会一个RST（重置）来表示这个情况。在这种情况下，套接字程序一般会打印“Connection reset by peer”。

## 数据完整性

在网络传输中，有很多可能会导致错误的事情，数据可能乱序到达，可能损坏，可能重复，甚至根本到达不了。TCP拥有处理所有这些意外事件的机制。

### 数据包顺序

发送端会在每一段中放置一个永远递增的序列号，比如“这一分段是3490号，这一分段是3491号”。接收端会回复一个带有发送端序列号的ACK数据包以表达“我收到了分段3490，我收到了分段3491。” 这样，如果有两段乱序到达，TCP仍然可以将它们按照顺序组装回来。
> 类比时刻！如果你有一叠文件，把它们扔向空中,
> 你如何能知道他们的原始顺序？如果，你正确的
> 用数字标示了每一页，你只需要将它们进行排序。
> 这就是TCP协议栈序列号的作用。

如果有重复的分段到达对端，接收端TCP知道该序号的分段已经被收到过了，所以可以安全的丢弃该分段。如果一个分段丢失了，TCP可以要求进行重传，它通过不停的给发送端发送上一个序号的分段的ACK消息来达到这一点，发送端将会再次重传下一个序号的数据。

或者，如果发送方在一段时间内没有收到特定段的ACK，它可能会认为该段可能已经丢失，发送端会重新传输该段。超时次数越多，这种重传的成功性变得越来越低;每次超时发生时，服务器端都会将超时加倍。

最后一点，在连接开始的三次握手中，序列号被初始化为随机值。

### 错误检测

在发送端发送出一个分段之前，一个基于该分段的 _校验和_将会同时被计算，当接收端收到这个分段时，它会基于收到的分段数据计算自己这一边的校验和。如果两边的校验和匹配，说明收到的数据是没有错误的。如果两次交验和不相等，数据将会被丢弃并且发送端会超时并且重传。 

校验和是一个将所有TCP报头和有效负载数据以及所涉及的IP地址作为参数，计算出来的一个16位数字，在下面的项目中，将会有对校验和的详细介绍。

## 流量控制

_流量控制_ 是一种让两个互相通信的设备告知对方数据需要发送更慢的机制，你不能直接向一个只能处理100Mbs设备倾倒1000Mbs(每秒百位数)数据，该设备需要告知发送端减缓速度。
> 类比时间：当你在电话里告诉对方的时候，你会这样说:
> "你说的太快了，我没听懂，请说慢一点!"

最简单的方法(这不是TCP所做的)是发送方发送数据，然后等待接收方发回带有该序列号的ACK数据包，接着发送端再发送一个数据包。按照这个思路，如果需要发送方放慢速度，接收方可以延迟ACK。

但这是一个缓慢的来回，网络通常足够可靠，发送方可以在不等待响应的情况下发送多个段。然而，如果我们这样做，我们冒着发送者发送数据的速度比接收者处理数据的速度快的风险!

在TCP中，采用一种叫做 _滑动窗口_ 的机制来解决这个问题，该机制会使用接收方的ACK包的TCP报头的“窗口”字段。在该字段中，数据接收方将会指定还可以接受多少数据（以字节为单位），随后的它收到的ACK信息将会携带新的窗口信息。使用这种机制，接收端可以让发送端知晓，“一旦你发送了X字节，你必须等待一个ACK，告诉你还可以发送多少字节“。值得一提的是，这里指的是字节数目而不是段数目，发送方可以自由地发送多个段而不接收ACK，只要总字节数不超过接收方所告知的窗口大小。

## 拥塞控制

流量控制是在两台计算机之间运行的一种机制，但如果放眼整个互联网，你会发现一个更大的问题。如果路由器不堪重负，它可能会开始丢弃数据包，导致发送者开始重传，这对缓解问题没有任何作用。它甚至没有在流量控制的雷达上，因为数据包没有到达接收端。

在1986年，在[NSFNET](https://en.wikipedia.org/wiki/National_Science_Foundation_Network)（商业互联网前身）上被不知道什么时候该停止重传的而一直坚持不懈发消息的发信人压垮了，吞吐量将至正常水平的0.1%，这不是一个很妙的事情。为了解决这个问题，TCP实现了一系列的机制来评估并且消除网络拥塞，请注意，这些都是在接收方发布的流量控制窗口之外的。发送方必须遵守流量控制限制**同时**计算的网络拥塞限制，以较低者为准。在网络上的未确认段数量不能超过此限制。如果超过了这个限制，它必须停止发送并等待一些ACK重新进入。

换个角度思考这个这个问题，当发送方发出一个新的TCP段时，它会增加网络拥塞。而当它重新收到一个ACK时，这表明该网段已从网络中删除，拥塞情况开始缓解。为了缓解在NFSNET遇到的该问题，加入了两个算法: 慢启动和拥塞避免。

**请注意:** 下面的介绍是这两个算法的一个简化版本，详细了解这俩之间复杂的相互作用，以及更多关于避免拥堵的方法，请查看[_TCP Congestion Control_ (RFC5681)](https://www.rfc-editor.org/rfc/rfc5681.html)。

### 慢启动

当连接第一次建立时，发送方是无法知道网络的拥塞程度。第一阶段的工作就是进行粗略的猜测。随意一开始发送端会谨慎的启动，假设在网络上有非常高级别的拥塞情况。（假设已经存在很高的拥塞水平，那么大量地向网络中填充数据将会雪上加霜。）

首先，它定义自己有一个初始 _拥塞窗口_，即允许有多少未被确认的字节(和段，但现在我们只考虑字节)未完成。当ACK收到后，拥塞窗口的大小随着已确认字节数的增加而增加。简单地描述，一个分段发送出去并收到确认之后，接下来可以开始尝试发送两个分段。如果这两个被也成功的收到了确认回复，那么可以一次性发送四个可分段。

所以，该机制会使用一个非常小的未被确认的分段数作为开始，一旦持续成功接收到回复消息，发送窗口会快速增长。最终如果线路中ACK丢失了，这时慢启动决定开始降速。它会将拥塞窗口大小减半，然后TCP切换到拥塞避免算法。

### 拥塞避免

该算法和慢启动类似，不过它会使用更多的控制步骤，不会是指数增长之类的方法。

每当一个拥塞窗口值的数据成功传输时，它会通过向窗口添加一个分段的字节来增加一点强度，该机制允许它在网络上拥有另一个未连接的段。如果回复正常，它允许该机制再次运行一次，如此反复。

因此，该机制主要是保持在不拥塞网络的情况下尝试发送最大限制的数据，但它的推进速度很慢。我们称之为 _加性增长_，它通常是线性的(相比之下，慢启动通常是指数的)。不过，这个机制触及了带宽上限，不得不重新传输数据包。此时，拥塞窗口被设置为较小的大小，算法退回到慢启动状态。

## 思考题

* 请列举几个依赖TCP实现数据完整性的协议。

* 为什么要用三次握手来建立连接?为什么不直接开始传输呢?

* 校验和事怎么保护数据完整性的？

* 流量控制和拥塞控制的不同点是什么？

* 思考下在慢启动和拥塞避免之间切换的原因。它们在拥塞检测的不同阶段有什么优势?

* 流量控制的目的是什么？
