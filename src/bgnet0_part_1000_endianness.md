# 整数和字节序

我们已经学习了一些通过网络传输文本的方法，但现在想做点别的:我们想传输二进制整数数据。当然，我们 _可以_ 直接将这些数字转换为字符串，但是有点多此一举浪费资源了。二进制的表示方法更加紧凑并且可以节省带宽。但是计算机网络只能发送和接收字节数据！我们怎么才能将任意的数字转换为字节数据呢？这就是这一节想要阐述的。我们想要完成:
* 将整数转换为字节序列
* 将字节序列转换回整数

在本节中，将会学习到:
* 数字是怎样表示为字节序列
* 这些字节序列的顺序是什么样子的
* 在Python中怎样把一个数字转化为字节序列
* 在Python中怎么把字节序列转化为数字

需要注意的部分:
* 任意整数都能被表示为一个字节序列。
* 在网络上发送之前，我们将会把整数转换为字节序列。
* 在从网络中收到之后，我们会将字节序列再次转化为整数。
* 两种不同表示字节序列的方法，_大端序_ 和 _小端序_。
* Python提供了内置的函数来将整数转化为字节序列并且将其转换回来。

## 字节表示法

在本节中，我们将深入研究如何用字节序列表示整数。

### 十进制字节表示

让我们看看整数是如何被表示为字节序列的，这些字节序列是我们将会通过网络发送给其他系统的整数数值。一个字节（在本节中，我们将一个字节等于8位）可以编码为`00000000` to `11111111`二进制数字，转化为十进制的话，表示从0到255的数字。

所以，如果当你想存储大于255的数字会发生什么呢？比如说256，在上述的规则中，你需要第二个字节去存储额外的数值。推而广之，越多的字节可以表示出越大的数。一个字节可以表示0到255，两个字节可以表示范围增大到0到65535。换个角度想，65536是16位比特能表示的数字的个数。

> 本节将只会讨论 **非负整数**。浮点数使用的是[不同](https://en.wikipedia.org/wiki/IEEE_754#Basic_and_interchange_formats)的方法。
> 负数使用和正数相似的方法来表示，不过为了简单起见，在本节中我们将暂时先不考虑它们。

让我们来看看用16位数字从253数到259的过程，因为259大于一个字节能表示的最大数，我们将用两个字节（一个字节可以表示0到255）来表示，下面是示例，相对应的十进制数在右边:
``` {.default}
  0 253   表示 253
  0 254   表示 254
  0 255   表示 255
  1   0   表示 256
  1   1   表示 257
  1   2   表示 258
  1   3   表示 259
```

注意，靠近右边的字节像里程表一样从`255`翻转”到`0`，就像在看一个以256为基数的编号系统。我们可以通过将第一个字节乘以256，然后加上第二个字节的值来得到相应的十进制数字:

``` {.default}
1  * 256 +   3 = 259
```

或者在本例中，两个分别为`17`和`178`的字节组合，表示值`1920`:

``` {.default}
17 * 256 + 178 = 1920
```

无论是`17`或者`178`都不大于`255`，所以它们都可以用一个字节表示。综上所述，所有的整数都可以完美的用一串字节表示，你可能需要在序列中使用更多的字节来表示更大的数字。

### 二进制表示法

二进制、十六进制和十进制都是表示数字的不同“语言”。因此，如果将上一节所有的十进制数字都替换为二进制，其中的数值和意思完全不会变化。为了验证这一点，让我们用上一节的例子来演示一下，请记住:这些数字完全相等——我们仅仅是把十进制转化为二进制，其他的所有概念都是完全相同的。

``` {.default}
00000000 11111101    表示  11111101 (253 十进制)
00000000 11111110    表示  11111110 (254 十进制)
00000000 11111111    表示  11111101 (255 十进制)
00000001 00000000    表示 100000000 (256 十进制)
00000001 00000001    表示 100000001 (257 十进制)
00000001 00000010    表示 100000010 (258 十进制)
00000001 00000011    表示 100000011 (259 十进制)
```

但是让我们稍安勿躁，观察一下上面的模式，如果你把这两个字节放在一起，你会得到和二进制表示完全相同的数字!(忽略前置的0。)实际上，我们所做的就是把一个数字的二进制表示分成8位的块, 我们可以使用任意数，比如1,256,616,290,962，并将其转换为二进制:

``` {.default}
10010010010010100001010101110101010010010
```

然后按照8位为一组，将其均匀的分隔开:

``` {.default}
1 00100100 10010100 00101010 11101010 10010010
```

犹豫我们需要将其装入一个个比特中，我们需要在`1`之前补上0，最终如下所示:

``` {.default}
00000001 00100100 10010100 00101010 11101010 10010010
```

现在你将得到最终的字节表示的数字结果1,256,616,290,962。

### 十六进制表示法

再次强调，使用什么进制并不是最重要的——它们只是表示数值的不同“语言”。程序员喜欢十六进制，因为它与字节非常的匹配（任何一个字节都是2个十六进制数字）。让我们再次以之前的例子作为说明，这次使用十六进制:
``` {.default}
00 fd    表示 00fd (253 十进制)
00 fe    表示 00fe (254 十进制)
00 ff    表示 00ff (255 十进制)
01 00    表示 0100 (256 十进制)
01 01    表示 0101 (257 十进制)
01 02    表示 0102 (258 十进制)
01 03    表示 0103 (259 十进制)
```

再仔细观察一遍!十六进制表示的数字与刚刚挤在一起的两个字节相同!真的是非常的方便！

## 字节序

准备好继续学习新知识了吗?在上一节中，我们刚刚了解到一个数字可以被表示位，比如(十六进制):

``` {.default}
45f2
```

也就是两个字节:

``` {.default}
45 f2
```

但是你知道吗？在一些系统之，会将其表示为`0x45f2`:

``` {.default}
f2 45
```

顺序完全颠倒了过来！这就好比我说“我想要123片吐司”，而实际上我想要321片!世界上对于这种颠倒放置字节的过程有一个专门的名称，我们称之为“小端序”。它表示的意思是数字的“小端”（书写序在后面的字节）位于整个字节序列的前端。

而相对的，更加正常化，更加便于理解的书写方法（就像我们最开始那样，数字`0x45f2`就是代表顺序`45 f2`）被称之为 _大端序_。 逻辑上位于前面的字节（也被称之为 _最高有效字节_ ）就放置在前面。

坏消息是事实上所有的Intel CPU都是小端序机器，好消息是Mac M1都是大端序机器。 不过最棒的还是 **所有在网络上传输的数字都是大端的**，使用的是一眼能理解的方式:

> 但我说“全部”的时候，我一般指的的是“一定的数量的”[^—Monty Python]。但是假使
> 两端都同意使用小端序来传输数据，并没有严格的规定不能这样做。这在发送端和接收端
> 都是小端序架构的机器中是很合理的-为什么去浪费时间将字节序列翻转发送之后再翻转
> 解析呢？不过绝大部分的协议都是大端序的。

在本章的关于网络概念的上下文中，大端序被称之为 _网络字节序_ 。

## Python和字节序

那么如何在Python中将数字转换成字节序列呢?幸运的是，Python中有一个内置的函数`.to_bytes()`可以完成这个工作，同时，还有一个反过来的从字节序列组成数字的函数`.from_bytes()`。这两个函数甚至可以运行用户来指定需要使用字节序！因为本文中都是通过网络传输数据，所以对于这两个函数我们永远使用的是`"big"`序列。

### 将数字转换为字节

下面我们通过一个具体的例子来展示如何将数字3490转换为一个两字节的大端序的字节数组。请注意，我们需要给`.to_bytes()`函数传入两个参数:需要转换的数字和字符串`"big"` 来表示我们需要大端序字节序列，或者`"little"` 来表示需要的是小端序序列。
> 新版本的Python会将默认值设置为`"big"`，不过在旧版本中，用户仍然需要显示的来指定这个参数。

如果我们将其打印出来，我们会看到这些字节的具体值:

``` {.default}
for b in bytes:
    print(b)
```

``` {.default}
13
162
```

这些是组成数字3490的大端字节序列值，我们可以简单的验证下，`13 * 256 + 162 == 3490`。

如果你尝试把数字70,000装入两个字节中，你将会得到`OverflowError`，两个字节不足以能够存储大于65535的数字——这里需要再增加一个字节。让我们来再看几个十六进制的例子:

``` {.py}
n = 0xABCD
bytes = n.to_bytes(2, "big")

for b in bytes:
    print(f"{b:02X}")  # Print in hex
```

将结果输出:

``` {.default}
AB
CD
```

你会发现，结果中的数位和变量`n`中存储的原始值一摸一样！

### 将字节转换回数字

让我们来完成一个完整的转换周期，之前我们是把一个十六进制数字转化为字节序例，并且将其打印出来看看最终的结果，下面，让我们把字节字符串转换回数字并且打印出来，以验证得到的结果和最开始的数字是一样的。

``` {.py}
n = 0x0102
bytes = n.to_bytes(2, "big")

print(bytes)
```

可以看到其输出为:

``` {.py}
b'\x01\x02'
```

最前面的`b`表示这时一个字节字符串(以便于区分于普通的字符串)，而`\x`是对于2位十六进制数字的转义符。由于我们的原始数字是`0x0102`，所以在字节字符串中的两个字节分别是`\x01` 和 `\x02`。现在，让我们将字符串转换转换回来并且以十六进制打印:

``` {.py}
v = int.from_bytes(bytes, "big")

print(f"{v:04x}")
```

我们可以看到结果是:

``` {.default}
0102
```

和原始的数值完全相同！

## 思考题
* 仅仅使用`.to_bytes()`和`.from_bytes()` 函数如何交换一个2字节数字的字节顺序？（也就是翻转字节。）思考下如何在不用循环和其他方法的情况下完成该操作（提示:`"big"` 和 `"little"`!）

* 用你自己的语言描述下大端字节序和小端字节序的差别。

* 什么是网络字节序？

* 为什么不直接传送整个数字而是要将其分解成为字节？

* 小端序是一种和人认知相反的表示方法，那么为什么会存在这种字节序？你可以搜集一些资料来了解下该问题的答案。

