# IP子网和子网掩码
[_本章中所有IP地址都会使用IPv4，而不是IPv6。 它们当中的逻辑是基本一样的，只是使用IPv4会更加利于学习基本原理._]

**如果你需要复习位操作，请参考[附录: 位操作](#appendix-bitwise)。**

在本章中将会介绍:

* 地址的表示方法
* 如何将点-数模式转换成一个数字
* 如何将一个数字转换为点-数模式
* 子网与进阶版主机知识
* 子网掩码进阶知识
* 从斜线表示法中寻找子网掩码
* 获取一个IP地址的子网，并且构建对应的子网掩码

## 地址的表示

回忆下前面说的，IPv4地址通常是以点-数表示法来表示的，举例来说`198.51.100.10`。这其中的每一个数字都是一个字节，其取值范围是十进制的0-255（也就是十六进制的00-FF，二进制的00000000-11111111）。所以，实际上，点-数表示法只是为了人可以更加方便的阅读。

> 高级技巧: 不同进制比如十六进制，二进制，和十进制只是数字的不同表示方法，这就像在各个
> 语言中，数字的表示都是不同的。
>
> 当使用一个变量表示数值是，最好是将其视为没有任何进制的纯数字。只有当你将其写下（无论是
> 代码或者打印出来）的时候，进制才会有意义。
>
> 比如，Python以十进制作为默认的方式打印所有的数，同时，它也提供了很多方法来将其输出转化
> 为其他进制的模式。

让我们来看看地址`198.51.100.10`的十六进制表示: `c6.33.64.0a`。

让我们把这些字节合并在一起组成一个单独十六进制的数:`c633640a`。继续将这个数`c633640a`转换为十进制，我们可以得到: `3325256714`。所以换句话来说，下面这些全部都表示一个相同的IP地址:

``` {.default}
198.51.100.10
c6.33.64.0a
c633640a
3325256714
```

清楚了吗？但是为什么要做这样的转换呢？

这是因为我们将要对IP地址做一些数学运算，现在，我们 _可以_ 对每个字节做一次运算并且也会得到正确的结果。但事实证明，如果我们把所有这些字节组合成一个数字，我们可以一次对所有字节进行计算，这变得更容易。下面会继续详细说明过程！

## 从点-数表示形式转换

本节的目标是将点-数形式的字符串`198.51.100.10`转换为对应的数值，比如十进制`3325256714`。我们可以依然使用前一节的字符串操作方法，不过这次让我们做的更加 _位运算_ 感强一点。

首先，让我们从IP地址中提取出单独的数字（Python可以使用`.split()`函数来实现）。字符串:

``` {.py}
"198.51.100.10"
```

可以转换为一串字符串数组:

``` {.py}
["198", "51", "100", "10"]
```

现在，让我们将开始处理这里面的每个数字。（在Python中，可以在一个循环中使用 `int()`函数，或者`map()`方法，或者使用列表表达式。）

``` {.py}
[198, 51, 100, 10]
```

下面，我将要用十六进制表示这些数字因为这样会使后面的步骤更加清晰，但是，清记住，这些只是被存储为一个数值，如果你不主动要求Python以十六进制打印它，你是看不到这个十六进制的。

``` {.py}
[0xc6, 0x33, 0x64, 0x0a]
```

为了构建我们自己的数字，我们需要依赖一些位操作，位运算的OR操作和位运算的shift操作。为了方便示例，让我们将其中的数学过程硬编码:

``` {.py}
(0xc6 << 24) | (0x33 << 16) | (0x64 << 8) | 0x0a
```

运行上述代码，Python会返回十进制数字`3325256714`，将其转化为十六进制，将会得到`0xc633640a`。

你可以用上面的方程将任意4字节的集合打包成为一个数字。
> 还有一个更加简洁的方法是使用循环依次处理每个字节。
> 试试看你能不能给自己增加点挑战！给你的助教私信你的答案，看看自己能不能完全正确！

## 转换成点-数形式

如果，你现在有是上一节的数值 `3325256714`，然后想把它转换为对应的IP地址，该怎么做呢？我们也可以使用一些移位的方法来完成这个转换！不过，我们需要做一些与操作并且利用掩码来得到每个需要的部分。

让我们先将其转换为十六进制，因为每一个字节都是2个十六进制数字，这使得我们能看的更清晰点:`0xc633640a`。下面，我么只要将这个数字分别向右移0个比特，8个比特，16个比特以及24个比特:

``` {.py}
0xc633640a >> 24 == 0x000000c6
0xc633640a >> 16 == 0x0000c633
0xc633640a >> 8  == 0x00c63364
0xc633640a >> 0  == 0xc633640a
```

如果你仅看最右边的两个比特，你会看到它们就是原始数字中的字节值:

``` {.py}
0xc633640a >> 24 == 0x000000 c6
0xc633640a >> 16 == 0x0000c6 33
0xc633640a >> 8  == 0x00c633 64
0xc633640a >> 0  == 0xc63364 0a
```

所以我们学到了一些东西，除了直接查看右移8位，例如，我们得到这个:

``` {.py}
0xc633640a >> 8  == 0x00c63364
```

所以，我只需要最右边的字节 `0x64` ，而不是其中的`0xc633`部分。我怎么才能把这其中的高位变成0并且去掉，而只留下 `0x64`？我们可以使用 _掩码与_ 运算！位与运算符可以像筛选器一样工作，让数字的一部分通过，并将其他部分归零。如果我们用字节`0xff`对该数字进行位与运算，那么相对的所有8位都设置为`1`，而除这8位之外的前面的所有位都隐含值`0`。

``` {.default}
  0x00c63364
& 0x000000ff
------------
  0x00000064
```

看！`0x64`就是我们想要从IP地址里得到的字节！可以仔细看下在掩码中有二进制`1`的地方(除了这里用十六进制表示)，它让值“显示通过”，而任何有零的地方都被清除了。按照这个方法，我们可以从中提取出我们需要的数值:

``` {.py}
(0xc633640a >> 24) & 0xff == 0x000000c6 == 0xc6
(0xc633640a >> 16) & 0xff == 0x00000033 == 0x33
(0xc633640a >> 8)  & 0xff == 0x00000064 == 0x64
(0xc633640a >> 0)  & 0xff == 0x0000000a == 0x0a
```

这些就是IP地址各个部分的单个字节值。为了得到最终的点-数字符串，你可以使用Python中的字符串f转换法，或者调用`.join()`函数。

## 子网和进阶版主机知识

让我们先回忆一下，IP地址被分成两个部分:子网号和主机号。IP地址左边的一些位是网络号，右边剩下的位是主机号。让我们再来看一个例子，这个IP地址左边的24位(3字节)是子网号，右边的8位(1字节)是主机号。

``` {.default}
 Subnet   | Host
          | 
198.51.100.10
```

所以这代表着在子网`198.51.100.0`中的`10`号主机。（在这里，我们将主机位替换为`0`的地址作为子网编号。）但我刚才单方面地说过，该IP地址有24个网络位。所以这样表示不是很简洁，于是诞生了斜杠表示法。

``` {.default}
198.51.100.0/24    前24位被用来标示子网
```

或者，你可以将该方法直接用于IP地址上:
``` {.default}
198.51.100.10/24   在子网198.51.100.0中的10号主机
```

让我们用同样的方法来表示一个16位的子网:
``` {.default}
10.121.2.17/16    在子网10.121.0.0中的编号为2.17主机
```

明白了么？
Get it?

在上面的例子中，我们使用的数字都是8的倍数，所以子网划分会在字节边界上对齐，但是这并不代表着不可以使用非8的整数倍的数字来表示子网范围:
``` {.default}
10.121.2.68/28   在子网10.121.2.64中的4号主机
```

如果你没搞明白上面的4和64是怎么来的，你可以把上面的字节都用二进制写出来！

## 子网掩码进阶

什么是 _子网掩码_?这是一串由`0`和`1`组成的序列，前面的一串`1`表示IP地址的哪一部分是网络部分， 它后面跟着一串二进制的`0`，表示哪一部分开始是标示主机的部分。这个可以用来标示一个IP地址属于哪个子网，或者说IP地址中哪些部分表示主机编码。

让我们试着用二进制来演示一下，我们将使用如下的IP地址作为例子:
``` {.default}
198.51.100.10/24   子网198.51.100.0中的10号主机
```

首先，让我们将它转换为二进制。（这里有一个提示，子网掩码是按位进行与运算的掩码!）

``` {.default}
11000110.00110011.01100100.00001010   198.51.100.10
```

现在，基于示例IP地址，让我们写下24个连续的`1`（因为这里有一个表示子网范围的`/24`）后面跟着8个连续的`0`（因为IP地址一共只有32位）。

``` {.default}
11111111.11111111.11111111.00000000   255.255.255.0  子网掩码!
   
11000110.00110011.01100100.00001010   198.51.100.10
```

这就是和`/24`子网相关联的子网掩码！`255.255.255.0`!

## 从斜杠表示法中求出子网掩码

如果我告诉你，现在有一个`/24`的子网，你怎样求出子网掩码是`255.255.255.0`？或者我告诉你`/28`的子网掩码是`255.255.255.240`，但是这是怎么得到的呢？

对于一个`/24`的子网，我们需要24个连续的`1`，后面跟着8个连续的`0`。
For a subnet `/24`, we need a run of 24 `1`s, followed by 8 `0`s.

[附录: 位运算](#appendix-bitwise)中介绍了好几种生产连续`1`的二进制数和移位的计算方法。一旦你有了那个大的二进制数，就需要使用我们在上面介绍的方法将它转换回点-数表示法。记住，子网可以使用任意位划分，`/17`也是一个合法的子网划分，它不需要必须是8的倍数！

## 在IP地址中提取子网

如果你有一个特定的以斜杠表示法表示的IP地址，比如：

``` {.default}
198.51.100.10/24   子网198.51.100.0中的10号主机
```

你怎么才能从其中只得到子网(198.51.100.0)和只得到主机号呢？你可以使用按位与运算！

首先，我们计算出子网 `/24`的子网掩码是 `255.255.255.0`。接着，让我们将它们都翻译成二进制并且将它们相加:

``` {.default}
  11111111.11111111.11111111.00000000   255.255.255.0  子网掩码
& 11000110.00110011.01100100.00001010   198.51.100.10  IP地址
-------------------------------------
  11000110.00110011.01100100.00000000   198.51.100.0   子网号！
```

我们也可以对这个整体进行一次性计算，而不是一次只计算一个字节……我们只需要将这些字节合成一个单一的值，就像我们在之前的章节中所做的那样:

``` {.default}
  11111111111111111111111100000000   255.255.255.0  子网掩码
& 11000110001100110110010000001010   198.51.100.10  IP地址
-------------------------------------
  11000110001100110110010000000000   198.51.100.0   网络号
```

与操作可以对于这个整体一次性的进行计算得到结果！接着，我们可以像前面的章节一样，将其转换为点-数表示法。现在，如果你有IP地址和子网掩码，并且想从IP地址中获得主机位，而不是网络位。你知道怎么做吗?(提示:位运算中的非运算符!)

路由器无时无刻不在进行这种计算--它们提取到IP地址并且需要它所处的子网是否符合任何一条它能路由到的地址。所以它会用掩码提取出IP地址的子网号，并且将其和自己知道的所有能路由的规则对比，接着匹配最佳规则并且将其转发。

## 思考题

* 将IP地址`10.100.30.90`转换位32位（4字节）十六进制表示是怎样的？用十进制表示呢？用二进制表示呢？ 
  <!-- 0x0a641e5a, 174333530, 0b1010011001000001111001011010 -->
 
* 32位数字`0xc0a88225`对应的点-数表示法的IP地址是什么？ 
  <!-- 192.168.130.37 -->

* 十进制数字`180229186`对应的点-数表示法的IP地址是什么？ 
  <!-- 10.190.20.66 -->

* 如果想从数字`0x12ff5678`提取第二个字节，需要的按位操作是什么?
  <!--
  shift, AND
  (n >> 16) & 0xff  or  (n & 0xff0000) >> 16
  -->

* 子网掩码`255.255.0.0`的斜线表示法的结果是什么？
  <!-- /16 -->

* `192.168.1.12/24`的子网掩码是什么？
  <!-- 255.255.255.0 -->

* 将斜杠表示法的子网掩码转换为二进制值所需的位操作是什么?
  <!--
  shift, subtract 1
  ((1 << m) - 1) << (32 - m)
  -->

* 给定一个IP地址值(一个32位数字)和一个子网掩码值(一个32位数字)，执行哪些位操作才能从IP地址中获得子网号?
  <!-- AND the two together -->

192.168.1.0是网络号，但不是子网掩码。子网掩码是由斜杠符号得到的点和数字的值。在本例中，它是 `/24`，转化为相应的子网掩码是`255.255.255.0`。
