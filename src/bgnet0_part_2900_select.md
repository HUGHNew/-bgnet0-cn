# Select函数

在这一章中，我们来看看 `select()` 函数。这是一个轮训系统所有套接字并让你知道哪些套接字向你发送了数据的函数。简单说就是准备调用`recv()`的对象。

这个功能使我们能够同时在大量套接字上等待数据。

## 我们要解决的问题

让我们假设有三个客户端需要连上我们的服务器，它想要`recv()`任何从客户端发过来的消息。但是，作为服务器端程序，它没有任何办法知道哪个客户端接下来将会发送什么数据。

此外，当服务器端对一个还没有数据到达的socket调用`recv()`时，`recv()`调用会产生 _阻塞_ ， 此时其他程序就不能运行了。

> _阻塞_ 的意思是进程将会停止执行并且在触发条件满足之前一直保持睡眠状态。在上面描述的
> 调用`recv()`的例子里，进程会一直保持睡眠状态知道收到一些数据。
> To _block_ means that the process will stop executing here and goes to
> sleep until some condition is met. In the case of `recv()`, the
> process goes to sleep until there's some data to receive.

因此，在这种状况下，我们会遇到如下的问题:

``` {.py}
data1 = s1.recv(4096)
data2 = s2.recv(4096)
data3 = s3.recv(4096)
```

假设`s1`上没有准备好的数据，那么进程将阻塞在那里，此时在 `s2`'或`s3`上调用的`recv()`将会一直等待，即使在这些套接字上有要接收的数据，函数也不会被调用。

所以，这里需要一个方法同时监控`s1`, `s2`, 和 `s3`，以判断它们之中哪个已经有数据准备好被接收了，接着只在这些套接字上调用`recv()`。

这就是`select()`函数所做的，在一系列套接字上调用`select()`会产生阻塞，直到这其中的一个或者多个套接字进入了就绪读取的状态。然后它返回给你哪些套接字准备好了，你可以在那些上调用`recv()`。

## 使用 `select()`

首先，你需要导入 `select`模块。

``` {.py}
import select
```

如果你准备测试一系列的已经有数据准备`recv()`并且已连接的套接字，你可以将它们放在一个`set()`中，然后传递给`select()`函数。该函数会产生阻塞知道有数据可以被读取。

此集合可以作为已连接套接字的标准列表，你需要把它们都记录在某个地方，集合就是一个不错的选择。当获得新的连接时，将它们添加到集合中，当连接挂起时，将它们从集合中删除。通过这种方式，它总是保存所有当前连接的套接字。

下面是一个示例，`select()`函数有三个参数，并且返回三个值，我们现在只看其中的第一个，忽略其他的。

``` {.py}
read_set = {s1, s2, s3}

ready_to_read, _, _ = select.select(read_set, {}, {})
```

此时，我们可以通过准备好的套接字来接收数据。

``` {.py}
for s in ready_to_read:
    data = s.recv(4096)
```

## 使用`select()`处理监听套接字

如果你认真思考，你可能有以下问题:如果服务器被阻塞在`select()`调用，并且在等待传入的数据，为什么它还能调用`accept()`来接受传入的连接?这些传入的连接不需要等待吗?此外，既然如果`accept()`被阻塞了，那么我们将如何回到`select()`，如果我们是在哪里被阻塞的？

幸运的是，`select()`函数给我们提供了如下的选项: _你同样可以添加监听套接字到初始集合中!_ 当监听套接字显示为“ready-to-read”时，这意味着有一个新的连接传入到`accept()`。

## 主要算法

让我们把所有的这些都放在一起，我们可以使用如下伪代码循环来完成`select()`功能:
``` {.default}
将监听套接字添加到集合 

main loop:
    
    调用select()函数并且获得可以进行读取的套接字 

    for 所有已准备就绪读取的套接字:
        if 套接字是一个监听套接字:
           调用accept()建立新连接
           将新的套接字加入我们的集合！
        
        else 如果套接字是一个普通的套接字:
            从该套接字recv() 数据

            if 收到了0个字节
               客户端已经挂掉
               从集合中删除该套接字
```

## `select()`函数中其他参数有什么用？

`select()` 函数包含三个参数。（虽然对于这个项目，我们只需要使用第一个，所以这一节纯粹是额外知识。）

它们分别是:

* 你想要监控哪些套接字为准备就绪可读状态
* 你想要监控哪些套接字为准备就绪可写状态
* 你想要监控哪些套接字为发生异常

下面的返回值也相应的映射到这些不同的值。

``` {.py}
read, write, exc = select.select(read_set, write_set, exc_set)
```

不过，对于本项目，我们仅仅只使用第一个返回值并且忽略其他的。

``` {.py}
read, _, _ = select.select(read_set, {}, {})
```

### 超时

我撒了个小谎，其实还有第四个可选参数，`timeout`。它是等待事件发生的秒数，以浮点数表示，如果在该时间范围内没有发生任何事情，`select()`函数直接返回，并且所有返回的套接字都不会显示为就绪状态。如果你只是想轮询所有套接字，你可以设置超时为`0` 。

## 思考题

* 为什么我们不能简单的对所有已链接的套接字直接调用`recv()`？`select()`给我们带来了什么好处？

* 当`select()`函数显示"已就绪有数据可读"时，此时对于一个监听套接字和非监听套接字的差别是什么？

* 为什么我们也要监听套接字加到集合中？为什么我们不直接先调用`accept()`，再调用`select()`?

## 在`send()`函数中使用`select()`

如果你的计算机尝试发送的速度太快，那么对于`send()`的调用同样可能会发生阻塞。也就是说，操作系统会使得其在处理待发送的积压数据时处于休眠状态。

但是，假设这里你真的不想有任何阻塞调用而只想保持不停的处理发送请求。你可以对`select()`函数的第二个参数是传入一个含有`send()` 函数使用套接字描述符的集合，这时，就不会发生阻塞操作。

这里，其工作原理和上面“套接字已经准备好读取”集合差不多。