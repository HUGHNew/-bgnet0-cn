# 项目：原子时间

在本项目中，你将要去访问获取NIST(美国国家标准与技术研究所)的原子钟，从他们的时钟上得到自1900年1月1日以来的秒数(这将是很多秒。)，并且将其输出。

于此同时，该项目还会输出你计算机上的本地系统时间，如果你计算机上的时钟是准确的话，这两个数字的输出应该非常接近:

``` {.default}
NIST time  : 3874089043
System time: 3874089043
```

本项目中，我们只是在写一个客户端,服务端程序已经存在并且时刻在运行。

## 法律声明

NIST的原子钟服务免费面向公众开放。但是一般来说，服务的开发者不希望未经授权的用户随意访问其服务器，有时，这可能是一个触犯法律的捷径。但是在本项目中，原子钟服务是开放并且欢迎公众使用的。

## 可用性声明

**查询NIST服务器的次数不能超过每4秒一次**，如果超出这个频率，它们会开始禁止程序进行查询。如果你想要周期化的运行该程序，请确保两次访问之间大于4秒。你可以在命令行中使用`sleep`来保证这一点。

``` {.sh}
sleep 4; python3 timeclient.py
```

## 纪元

在计算机用语中，“纪元”指的是从计算机视角的“时间的开始”。许多库都以“自epoch以来的秒数”来测量时间，意思是自时间开始以来的时间。我们所说的时间之初是什么意思?这要分情况来描述，在Unix世界中，时间开始的定义是非常具体的1970年1月1日00:00 UTC(又名格林威治标准时间)。

其他的epochs，时间的开始可能是其他的时间。比如，在时间协议中，时间的开始被定义为1900年1月1号的0点（UTC时间），而这是Unix所规定的开始时间的70年前。而这些意味着，我们需要做一些转换，幸运的是，我们将会直接给出返回正确数值的代码，而你完全不需要担心这些。


## 关于零的可怕警告

我也不知道什么原因，有时候NIST服务器会返回四个字节的全0字节，而有时，它将会发送0字节然后关闭连接。如果这件事发生了，你大概率会看到在NIST时间里出现了`0`。这时，只要尝试再次运行你的客户端，看看你是否在一次或两次尝试后获得良好的结果，请记住每4秒查询一次的限制。对于`time.nist.gov`，背后有一些轮换的IP，并且很可能在某一天，一两个服务器不能正常工作。不过如果，如果服务器一直返回0，那么大概率是有其他的错误了。

## 整体方案

对于这个项目，下面是整个的程序逻辑:
1. 在端口`37`上连接`time.nist.gov`（时间协议）。
2. 接收数据（客户端不需要发送任何内容。），客户端应该能收到4字节的回复。
3. 这4个字节是一个4字节大端序数字，使用`.from_bytes()`将这4字节解析成一个数值。
4. 将这个从时间服务器返回的数值打印出来，这个数字是从1900年1月1日0点0分经过的秒数。
5. 获取系统本地时间，将其转换为以从1900年1月1日0点0分经过的秒数进行输出。

如果你的电脑时钟是准确的，这两个时间应该大致(或完全)一致。这个数字应该比38.7亿多一点，而且它应该每秒增加一次。

### 1. 连接服务器

时间协议通常与UDP和TCP一起工作。对于这个项目，就像我们之前其他项目一样，必须使用TCP套接字。所以创建一个套接字，并且通过时间协议在`37`端口连接 `time.nist.gov`。

### 2. 接收数据

技术上，你应该使用一个循环来完成此步骤，不过，一般来说，如此小量的数据一般不会被分割为很多数据包进行传输。无论你要求一次收到多少数据，最多你都只会收到4个字节的数据，当接收完数据之后，你可以关闭该套接字。

### 3. 解析数据

接收到的数据是一个被编码在大端4字节中的数字。调用之前我们提到的`.from_bytes()`函数以从`recv()`字节流中解析出该数值。
The data is an integer encoded as 4 bytes, big-endian.

### 4. 打印NIST时间

得到的时间应该是这样的格式:

``` {.default}
NIST time  : 3874089043
```

### 5. 打印系统时间

下面是一段Python代码，它用来获取并打印自1990年1月1日0时0分系统时钟，你可以简单的将其粘贴进你的代码来直接获取系统时间。将系统时间以以下的形式直接输出在NIST时间之后:

``` {.default}
System time: 3874089043
```
这里是相应的代码:

``` {.py}
import time

def system_seconds_since_1900():
    """
    The time server returns the number of seconds since 1900, but Unix
    systems return the number of seconds since 1970. This function
    computes the number of seconds since 1900 on the system.
    """

    # Number of seconds between 1900-01-01 and 1970-01-01
    seconds_delta = 2208988800

    seconds_since_unix_epoch = int(time.time())
    seconds_since_1900_epoch = seconds_since_unix_epoch + seconds_delta

    return seconds_since_1900_epoch
```

假设NIST返回的数字不是0:
* 如果这个数字与NIST的数字相差不到10秒，大功告成。

* 如果相差在86,400秒内，也没有关系，我很想知道，因为这可能是上面代码中的一个bug。

* 如果相差在1百万秒内，那么我很想你能告知我。

* 如果差距大于上面的数字，那么大概率是你的代码中有bug。你是否使用了`"大端"`字节序？你时候接收了完整的4个字节？

<!-- 评分表
55 分
-5分 程序使用的是TCP套接字
-10分 程序成功的在37号端口连接上了time.nist.gov
-10分 程序从服务器端接收到了数据
-5分  程序在接收完数据之后正确关闭了套接字
-10分 程序正确解析了从服务器传回来的数据
-5分  程序正确的打印出了结果
-10分 两个时间的差值在86,400秒以内
-->
<!-- Rubric

55 points

-5 Program uses TCP sockets
-10 Program connects successfully to time.nist.gov port 37
-10 Program receives data from the server
-5 Program close()s the socket after receiving data
-10 Program properly decodes data from server
-5 Program properly prints out results
-10 Results are within 86,400 seconds of each other

 -->
