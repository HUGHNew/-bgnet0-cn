# 项目: 验证TCP数据包

在本项目中，你将会编写一些代码来检验TCP数据包，保证其在传输的过程中并没有损坏。

**输入**: 一对文件序列:
* 一个以点数模式保存了源和目的地IPv4地址的文件
* 一个同时含有TCP包头和负载的原始TCP数据包
你可以[fls[在此文件夹中下载到这些数据｜tcpcksum/tcp_data.zip]]。

**输出**:
* 对于每一个文件对，如果TCP校验和相同，那么就打印`PASS`，如若不然，打印 `FAIL`。

本项目中有很多知识点，所以强烈建议你自己动手编写程序和和进行测试。

**在你开始你预想的方法之前，你应该100%理解此规范!在世界编码之前先弄清楚相关概念!**

**本项目最难的部分是理解其中的知识点！在你完全理解之前，你的代码将不会工作！**

**标准答案只有37行代码！**（不包括空格和注释。）这不意味着这是一个需要被超越的数字，但这表明你需要付出多少努力来理解里面的知识点，而不是编写代码!

## 禁止使用的函数

在本项目中，你不能使用任何`socket`库中的函数。

## 如何编码

虽然你可以以任何你喜欢的方式来做这个，不过我推荐你按照如下的顺序来实现，每一步的细节将会在后面的章节里详细说明。
1. 读取`tcp_addrs_0.txt`文件。
1. 将里面的内容分为两个部分，源地址和目的地地址。
1. 编写一个将点-数格式的IP地址转换为字节字符串的函数。
1. 读取`tcp_data_0.dat` 文件。
1. 编写一个从`tcp_addrs_0.txt`所含的IP地址生成IP伪包头的字节序列和从`tcp_data_0.dat`生产TCP数据长度的函数。
1. 构建一个新版本的校验和为0的TCP数据。
1. 拼接伪包头和上面校验和为0的TCP数据。
1. 从`tcp_data_0.dat`提取原始的校验和。
1. 对比两个校验和的值，如果相同，说明程序正确。
2. 修改你的函数，使其能够处理所有10个文件。**头5个文件应当有可以匹配上的校验和，而后5个文件的校验和匹配不上！**也就是说，后五个文件模拟的是在传输中数据损坏。

## 校验和

TCP中校验和是一个16位的表示数据包所有字节“总和”的数值。（再补充一点，不是说它真的等于所有字节值的和！！！后面会进行详细介绍。）TCP包头本身包含了一个从发送端计算出的校验和。

接收端主机（也就是你现在假装的这一部分）独立从接收到的数据中计算校验和，并且保证它和发送端发送过来的校验和完全一致。如果是一致的，说明该数据包是好的，如若不然，那说明已经有错误了，要么是源IP地址值错了，要么是目的地IP地址值错了，抑或是TCP包头损坏了，或者是数据本身已经发生错误了，还有种情况，就是校验和自己已经损坏了。不管是哪种情况，如果校验和不一致，操作系统中的TCP软件都会请求一次重发。

在本项目中，你的工作是基于给出的数据计算校验和，以及保证它匹配（或者不匹配）输入数据中已经存在的校验和的值。

## 输入文件详情

**请在下载 [fls[this ZIP|tcpcksum/tcp_data.zip]] 输入文件**。

输入文件一共有10批，其中5批含有正确的校验和，第二批的五个是损坏的校验和。以防你没有理解到重点，前面这句话是你需要在该项目中100%取得的结果。这批文件名规则如下:

``` {.default}
tcp_addrs_0.txt
tcp_addrs_0.dat

tcp addrs_1.txt
tcp addrs_1.dat
```

一直到序号9，每一对文件都是相互相关的。

### `.txt` 文件

你可以使用编辑器看下 `tcp_addrs_n.txt` 文件，其中包含了一对随机的IP地址，如下所示:

``` {.default}
192.0.2.207 192.0.2.244
```

这些表示该TCP数据包的 _源IP地址_ 和 _目的地IP地址_ 。为什么在计算TCP校验和的时候我们需要IP信息呢？继续往下看。

### `.dat`文件

这是一个二进制文件，包含原始TCP头，紧随其后的是负载数据。如果你在编辑器里打开他，他看起来就像是一堆垃圾值，如果你的电脑上装有hexdump，你可以看到其中具体的字节信息，比如，下面是来自`hexdump`的输出:

``` {.sh}
hexdump -C tcp_data_0.dat
```

``` {.default}
00000000  3f d7 c9 c5 ed d8 23 52  6a 15 32 96 50 d9 78 d8  |?.....#Rj.2.P.x.|
00000010  67 be ba aa 2a 63 25 2d  7c 4f 2a 39 52 69 4b 75  |g...*c%-|O*9RiKu|
00000020  42 39 53                                          |B9S|
00000023
```

但在本项目中，文件中你真正需要关心的只有:
* 数据的长度（以字节表示）
* 存储在偏移量16-17的十六进制大端表示的校验和

在后面我们会继续详细介绍！

请注意：这些文件中都是一个“非正式正确”的TCP包头，虽然所有的字段都在，但是大部分数值（特别是那些标志以及可选字段）可能都是没有意义的。

## 到底如何计算TCP校验和？

具体过程并不是那么简单。

这里的TCP校验和主要用来检验这些事情:
* TCP包头
* TCP负载
* 源IP地址和目的地IP地址（防止在TCP流中包含有错误路由的信息）

最后一部分相当有意思了，因为IP地址信息完全不在TCP包头或者数据中，那么我们怎么将其囊括在校验和中呢？

TCP校验和是一个按照如下方法计算的两字节数字，对于一个特定的TCP包头数据，负载，以及源和目的地IP地址数据:

* 构建一个代表IP伪包头（后面会详细介绍）的字节序列

* 将当前TCP包头的校验和初始化为0

* 将IP伪数据头和TCP包头以及负载连结起来

* 基于上面的连接数据计算校验和

这就是计算TCP校验和的全过程，不过具体过程还有很多细节。

## IP伪包头

因为我们想要确保数据中的IP地址是正确的，所以我们需要在校验和中包含IP报头。只不过我们没有包含真正的IP报头。我们只需要一个假的，它看起来是这样的(下图是直接从TCP RFC中窃取的):

``` {.default}
+--------+--------+--------+--------+
|           Source Address          |
+--------+--------+--------+--------+
|         Destination Address       |
+--------+--------+--------+--------+
|  Zero  |  PTCL  |    TCP Length   |
+--------+--------+--------+--------+
```

别让上面的网格形式混淆了你：实际上的IP伪包头市一个字节的字符串，上面的表示形式只是为了更容易人类阅读。

上面图表中的每个`+`都代表一个字节分割符。因此，源地址是4字节。（嘿！因为IPv4地址长度本来就是4字节！），**你可以在`tcp_addrs_n.txt`文件中看到这个信息**。目的地地址也是4个字节， **你也可以在`tcp_addrs_n.txt`文件中看到这个信息**。 

数据0是一个字节，对应的16进制字节形式值是`0x00`。PTCL是协议名，这一个字段永远都会被设置为值`0x06`。（IP有一些神奇的数字来表示它上面的更高级别的协议。TCP的编号是6。这就是它的由来。）

TCP长度就是数据总长度，以大端字节序表示的TCP数据包和数据总大小。**这其实就是你需要从文件`tcp_data_n.dat`读取数据的长度。**

因此，在计算TCP校验和之前，你必须首先创建一个IP伪包头!

### 伪包头实例

如果目的地地址IP是 `255.0.255.1`而目的地地址是`127.255.0.1`，相关的TCP数据长度是3490 (十六进制 0x0da2)，对应的伪包头会如下面所示:

`Z` 是数字0的部分，而`P`是协议（永远是6）。看到字节是如何与输入对齐的了吗?（255是十六进制0xff, 127是十六进制0x7f, 等等。）

### 获取字节形式的IP地址

如果你已经注意到的话，文件`tcp_addrs_n.txt`中的IP地址是点数模式的，不是二进制模式的。**你将需要编写一个函数来将点数字符串转换为了4字节的序列。**

算法步骤:
* 将点数模式转换为一个四个整数的数组
* 调用`.to_bytes()`将上面的每个数字转换为字节
* 将上面的结果全部组装起来成为一个单独字节字符串

该函数会采用一个点-数形式的IPv4地址，并且返回一个四字节的字节数组作为结果。下面是一个示例测试：

* 输入: `"1.2.3.4"`
* 输出: `b'\x01\x02\x03\x04'`

然后，只需要对输入文件里面的每个IP地址都调用该函数，最后将他们拼接到伪包头后面。

### 获取TCP数据长度

这一步很简单: 只要你读取了`tcp_data_n.dat` 文件里面的任何一个，你就能得到数据的长度。

``` {.py}
with open("tcp_data_0.dat", "rb") as fp:
    tcp_data = fp.read()
    tcp_length = len(tcp_data)  # <-- right here
```

**请注意，这里在读取的二进制数据时候一定要使用`"rb"`模式！这就是这里`b`的涵义！如果你不按这个来做的话，可能会导致一切都不成功!**

## TCP 包头校验和

当计算校验和时，我们需要一个将校验和字段设置为0的TCP包头。同时还需要从我们收到的TCP报头中提取现有的校验和，以便我们可以将其与我们计算的校验和进行比较!这个图式很庞大，但好在我们实际上只关心其中的一部分。所以暂时可以跳过这一段，先查看下一段。

``` {.default}
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

（再次说明，就像之前的IP伪包头一样，实际上的TCP包头是被编码过的数据流，而上面的网格模式只是便于人类可读。这个图表是一共是32个小格，数字都标示在上方。）

找一下上面的的TCP包头哪里含有`Checksum`？这是本项目中最关心的部分，它是一个位于TCP包头中，偏移量为16字节和17字节两字节的数字（大端序）。所以在`tcp_data_n.dat`文件中，该字段也是位于TCP包头偏移量16-17字节处（然后是TCP有效载荷）。

**你需要该文件中的校验和数值，方法是首先使用切片获取这两个字节，然后使用`.from bytes()`将其转换为数字。这是你需要最终进行对比的原始校验和!**

**同时你也需要生成校验和置为0的一份TCP包头和数据，你可以使用如下的方法得到该值:**

``` {.py}
tcp_zero_cksum = tcp_data[:16] + b'\x00\x00' + tcp_data[18:]
```

看到这里我们如何构建一个新版本的TCP数据了吗?方法就是将现有校验和前后的所有数据切片，并在中间放置两个零字节。

## 计算校验和详细步骤

终于，我们要开始学习计算校验和的具体方法了，目前我们已经完成了如下步骤:
* 构建IP伪包头
* 从已有的TCP包头中提取校验和
* 构建一个校验和为0的TCP包头

下面我们将要学习详细的计算了，这是定义中描述的:

> 校验和字段是一个用反码相加所有包头中16位的数，然后再对结果取反的一个操纵。

这下好了，这个概念使我们理解更加混乱了，这到底是什么鬼东西？

反码是一种二进制表示正整数和负整数的方法，幸运的是，我们不需要知道关于它的具体细节。但是，有一件我们需要注意的是，所有我们讨论的都是“16位的字”。。。这又是什么意思呢？

这意味着我们不再把所有这些数据看作是一堆字节，而是把它看作是一个16位整体的值。所以，如果你看到如下这些字节：

``` {.default}
01 02 03 04 05 06
```

我们需要把它看作3个16位的数字：

``` {.default}
0102 0304 0506
```

接下来，我们要把他们以反码的加法加起来。嗯。。。但是如果这里有奇数个字节怎么办？

> 如果一个段包含奇数个需要被计算校验和的头部和八元组数据，校验后，最后一个八位元组在
> 右侧填充零，最后一个填充了正确零数量的八元组组成了一个可被计算校验和的16位字。

所以，我们需要看一下用来填充`tcp_length`字段的`tcp_data_0.dat`文件的长度，如果它是一个奇数，那么就在整个数据的后面加上零。

方便的是，我们已经有了一个可以使用的TCP数据副本:我们将校验和归零后生成的版本。因为我们无论如何都要迭代访问这个版本的数据，所以不妨将0字节附加到它后面:

``` {.py}
if len(tcp_zero_cksum) % 2 == 1:
    tcp_zero_cksum += b'\x00'
```

而这可以保证它的长度是一个偶数。我们可以像下面这样提取所有的16位值。记住，要校验和的数据包括伪报头和TCP数据(校验和字段设置为零):

``` {.py}
data = pseudoheader + tcp_zero_cksum

offset = 0   # byte offset into data

while offset < len(data):
    # Slice 2 bytes out and get their value:

    word = int.from_bytes(data[offset:offset + 2], "big")

    offset += 2   # Go to the next 2-byte value
```

太棒了！这个循环遍历整个数据块中的所有的字。但这能给我们带来什么呢?校验和是多少?让我们使用上面的循环框架并且把校验和的代码放在里面。

让我们再回到补码的部分，和一些16位相关的特性，在Python中，这些都有些棘手因为Python用的都是任意精度整数。但是，下面是我们想怎样来计算它，在下面的例子中，`tcp_data`是使用0来补齐成偶数长度来计算校验和的TCP数据。

``` {.py}
# Pseudocode

function checksum(pseudo_header, tcp_data)
    data = pseudo_header + tcp_data

    total = 0

    for each 16-bit word of data:  # See code above

        total += word
        total = (total & 0xffff) + (total >> 16)  # carry around

    return (~total) & 0xffff  # one's complement
```

上面例子中“可以学到的小知识”就是反码的计算，其中到处存在的`&0xffff`是强制Python会给我们一个16位的整数。

还记得说明中是怎么说的么？
> 校验和字段是一个用反码相加所有包头中16位的数，然后再对结果取反的一个操纵。

上面的循环告诉了我们什么叫做“反码的加法”，结尾的`~total`给我们演示了是那么叫做对结果取反。

## 终极对比

现在，你已经计算了TCP数据的校验和并且同时也从TCP数据中提取出了已存在的校验和，下面可以进行对比了。如果他们是相等的，说明数据是一致而且是正确的，如果它们不想等，那么说明数据损坏了。在示例数据中，开始的五个文件是一致的，后面的五个是损坏的。

## 输出

你程序的输出应该展示出哪些TCP数据对比是通过的，哪些是失败的，也就是说，下面是应该是你的输出的样子。

``` {.default}
PASS
PASS
PASS
PASS
PASS
FAIL
FAIL
FAIL
FAIL
FAIL
```

## 胜利

世上无坦途，夸赞一下得到正确结果的自己吧！

<!-- 计分表
100 分

10分 实现了正确实现了将点-数形式转换为4位大端序字节的函数
5分  正确构造出二进制的含有源IP地址和目的地IP地址的伪包头
5分  伪包头中置0位填的是0
5分  伪包头中协议字段填写的是二进制0x06
5分  伪包头中有正确的16位大端序表示的TCP段长度
5分  有连接TCP包头和数据的校验和
5分  校验和正确的补齐了完整的数据到一个偶数字节长度
10分 校验和是基于16位字来计算的
10分 校验和算法中的反码运算是正确的
5分  校验和在返回之前被取反过
5分  校验和正确的被转换为16位
10分 所有10个文件都被处理了
5分  原始校验和被正确的提取出来
5分  正确构造出校验和是0版本的TCP数据
10分 最终结果中的"PASS"/"FAIL"都是正确的
-->
