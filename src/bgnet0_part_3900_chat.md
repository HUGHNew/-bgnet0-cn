# 项目: 多客户端单服务器聊天程序

现在，让我们把之前学习的所有东西都用到一起，完成这个终极项目！

我们将实现一个多用户聊天服务器和与之配套的聊天客户端程序。

在本项目中，聊天服务器程序应该允许任意数量的来自客户机的连接，每个客户端都可以看到其他客户端在说什么。不仅如此，当用户加入或离开聊天时，还会有对应的消息。

下面是一个示例截图。输入提示符后室用户(在本例中为“pat”)他将要说的话，在其之上的区域是所有之前的聊天记录。

``` {.default}
*** pat has joined the chat
pat: Hello?
*** leslie has joined the chat
leslie: hi everyone!
pat: hows it going
*** chris has joined the chat
chris: OK, now we can start!
pat: lol
leslie: Why are you always last?
*** chris has left the chat

pat> oh no!! :)█
```

## 总体架构

我们的程序中只有一个服务器，它可以同时处理许多客户端连接。

### 服务器端程序

服务器端程序将使用 `select()`调用来处理多个连接，以查看哪些连接已准备好，可以从中读取信息。

侦听套接字本身也将包含在此集合中，当它显示“ready-to-read”时，这意味着有一个新的连接可以被`accept()`。而如果任何其他已经accept的套接字显示“ready-to-read”，这意味着客户端已经发送了一些需要被处理的数据。

当服务器程序从一个客户机获得聊天数据时，它会将该聊天消息重新广播给每个连接的客户端程序。

> 注意：当我们在这里使用“广播”术语的时候，指的是我们大众意义上的把一个消息告知很多
> 人。而**不是**指的是IP或者因特网的广播地址。在本项目中，我们不会用到这个概念。

当一个新客户端连接或者断开时，服务器端程序也会广播该消息给所有客户端。因为很多客户端会发送消息给服务器端，服务器需要为 _每一个客户端_ 维护一个数据包缓存。

> 你可以使用Python中的`dict`，用客户端的套接字本身作为键，缓冲区作为值，这样就得到了套接字到缓冲区的映射。

服务器端程序通过在命令行指定一个端口来运行，在本项目中，这是一个强制要求的选项，在这里没有默认端口。

``` {.sh}
python chat_server.py 3490
```

### 客户端程序

客户端启动时，用户在命令行中指定自己的昵称(AKA“nick”)以及想要连接的服务器信息。

客户端发送的第一个数据包是一个包含昵称的“hello”数据包。(这就是服务器如何将连接与nick关联起来，并将连接事件重新广播给其他客户端的方法。)

在此之后，用户在客户端程序中键入的每一行都将作为聊天数据发送给服务器。客户端程序从服务器获得的每个聊天数据包(或连接或断开连接数据包)都会显示在其屏幕输出上。

客户端程序有一个 **文本用户界面**（TUI）用来保持输出界面整洁。由于输出是在屏幕的不同部分异步发生的，而不是在输入部分，因此我们需要执行一些终端显示技巧来防止它们相互覆盖。该TUI代码将在下一节中提供并描述。

由于在用户输入内容时可能会有数据到达，因此我们需要一种方法来处理这种情况。基于此，客户端程序将是**多线程**的，会有两个运行的线程。

* 主线程主要完成以下工作:
  * 读取键盘输入
  * 将聊天消息从客户端发送给服务器
* 接收线程要要做的是:
  * 从服务器端接收数据包
  * 在屏幕上显示结果

由于这些线程之间没有共享数据的需求，因此不需要同步(互斥锁等)。

> 是的，他们会共享套接字，不过操作系统会保证多个线程在同一时间使用同一个套接字不会产生
> 资源竞争。它是一个 _线程安全_ 的资源。

如果你需要学习更多关于Python多线程的知识，请参见[Appendix:Threading](#appendix-threading)。客户端程序将通过在命令行上指定用户的昵称、服务器端地址和服务器端口来启动。这些都是必需的参数，在客户端程序中没有对应的默认值。

``` {.sh}
python chat_client.py chris localhost 3490
```

## 客户端I/O

客户端屏幕有两个主要区域：
* 输入区，屏幕最下方的一两行。
* 输出区，屏幕上方的其他部分。

(下面的客户端TUI部分详细介绍了如何实现这些I/O的具体逻辑。)

屏幕底部的客户端输入行是用户的昵称，后面跟着 `>` 和一个空格。在此之后输入内容:

``` {.default}
alice> this is some sample input
```

输出区有两种主要消息:
* **聊天消息**: 显示说话人的昵称，后面跟着“:”和一个空格，然后是用户的具体聊天内容。
The output area of the screen has two main types of messages:

  ``` {.default}
  pat: hows it going
  ```

* **信息消息**: 这些消息用来显示用户何时加入或离开聊天，或需要打印的任何其他系统信息。它们首先是`***` 和空格，然后是具体的消息。加入和离开的消息模版如下:

  ``` {.default}
  *** leslie has joined the chat
  *** chris has left the chat
  ```

### 用户特殊输入

如果用户输入以`/`开头，则表示该消息具有特殊含义，应进一步解析以确定具体的内容。目前，唯一的特殊输入被定义为`/q`:
* **`/q`**: 当用户输入这个消息时，客户端会退出。在这种情况下，没有任何内容会被发送到服务器。

## 客户端TUI

[fls[可以从这里下载聊天UI的代码和演示|chat/chatui.zip]]。

在文件 `chatui.py`中，有四个你需要的函数，你可以通过下面的代码导入它们:

这些函数的功能是:
* **init_windows()**: 在实现其他面向UI的I/O代码之前需要先调用这个，它还应该在启动接收线程之前调用，因为该线程执行I/O操作。

* **end_windows()**: 当你的程序结束之后，可以调用此函数清除一切。
  
* **read_command()**: 本函数将在屏幕底部打印提示并接受用户输入。它返回用户按下`ENTER`键后输入的行。
  举个例子:
  ``` {.py}
  s = read_command("Enter something> ")
  ```
  该函数负责正确显示元素在屏幕上的位置。

* **print_message()**: 将消息打印到屏幕的输出部分。此函数会处理滚动并确保输出不会干扰到从`read_command()`读取的输入。无需在输出中添加换行符，它会自动的被添加上。

**已知问题**: 在Mac上，如果有消息通过`print_message()`打印出来之后，接下来再按下删除键会显示一个 `^R`并且会向下滚动一行。暂时还不知道是什么原因。

### `chatui`的Curses变种

如果`chatui` 库使用的不那么顺手，你可以尝试另一个增强版本`chatuicurses`。它具有完全相同的功能，并且以完全相同的方式使用。在你使用这个版本的之前，你需要安装unicurses库:

``` {.sh}
python3 -m pip install uni-curses
```

在安装以后，你可以import `chatuicurses`而不用import`chatui`。

**Mac版本已知问题**: 在我的Mac机器上会抱怨说curses库没有安装，而实际上它已经安装了。但是这在Linux或Windows没有影响。

**一个限制** 使用该库会导致`CRTL-C` 不能退出应用程序。因此，你可能需要按下 `CRTL-C`并且后跟`RETURN`才能真正退出。在Windows上，你可以尝试`CTRL-BREAK`。

## 数据包结构

客户端程序和服务器程序将通过TCP(流)套接字，使用自定义的数据包结构进行通信。

简而言之，数据包是有一个表示有效负载长度的16位大端数字和字符串表示的有效负载组成，其中使用UTF-8编码的json格式数据。

> 你可以通过在字符串上调用 `.encode()`函数将JSON字符串编码为UTF-8字节。`.encode()` 
> 函数使用一个参数来指定编码，在默认情况下，它是`"UTF-8"`。

因此，在查看数据流时，首先要做的是确保缓冲区中至少有两个字节，这样可以知道JSON数据的准确长度。然后，查看缓冲区中是否有相应长度(2字节头加上2)的数据。

## JSON 负载

如果你对JSON不是很熟悉，可以查看[Appendix: JSON](#appendix-json)节。

每个数据包都是由一个两字节的表示长度的负载，后跟具体负载组成。具体的负载是以UTF-8编码的的json字符串。每个有效负载都是一个Object，并且在其中有一个名为`"type"`的字段，表示有效负载的类型。其余字段根据类型而相应改变。

在下面的示例中，字符串中的方括号用于表示需要放入相关信息的位置。括号**不**包含在数据包中。

### 负载“Hello”

当客户端第一次连接上服务器时，它会发送一个带有用户昵称的“hello”数据包。它的目的是使得服务器可以将来自nick的客户端和自己本地维护的连接相关联。此数据包须在其他数据包之前发送。从客户端发送给服务器端的消息形式为:

``` {.json}
{
    "type": "hello"
    "nick": "[user nickname]"
}
```

### 复杂"Chat" 

该数据包是具体的聊天消息。它有两种形式，取决于聊天消息是来自客户端(即用户想要发送消息)还是服务器端(即服务器正在广播其他人的消息)。

从客户端发送给服务器端的消息为：

``` {.json}
{
    "type": "chat"
    "message": "[message]"
}
```

从服务器端发送给客户端的消息为：

``` {.json}
{
    "type": "chat"
    "nick": "[sender nickname]"
    "message": "[message]"
}
```

客户端不需要将发送方的用户名nick与数据包一起发送，因为服务器已经可以从之前发送的`hello`数据包获得对应的连接。

### 负载"Join" 

当有客户端加入此聊天时，服务器端程序会发送此负载给所有客户端。

``` {.json}
{
    "type": "join"
    "nick": "[joiner's nickname]"
}
```

### 负载"Leave"

当有客户端离开此聊天时，服务器端程序会发送此负载给所有客户端。

``` {.json}
{
    "type": "leave"
    "nick": "[leaver's nickname]"
}
```

## 扩展

下面的内容不会被记入得分，不过，如果你想进行根更深的探索，这里有一些方向。**警告！**请确保你提交的任何内容首先得包含了上面的要求。这些扩展模块只是一个严格的超集，或者你可以fork一个新项目来保存它们。至少，我建议从你的工作版本进行分支，这样就不会意外地搞砸了！

* 添加直接消息功能——如果用户“pat”发送:
  ``` {.default}
  /message chris how's it going?
  ```
  then "chris" will see:
  ``` {.default}
  pat -> chris: how's it going?
  ```
  (如果用户不存在怎么办?也许你需要定义一个从服务器返回的对应的错误包消息！)

* 添加一个方法来列出聊天中所有人的名字。
  
* 添加表情——如果用户“pat”发送:
   ``` {.default}
  /me goes out to buy some snacky cakes
  ```
  everyone else sees:
  ``` {.default}
  [pat goes out to buy some snacky cakes]
  ```
  (此功能正确的方法是添加一个新的数据包类型!)

* 添加聊天室功能 -- 当每个人第一次加入时，可以有一个默认的聊天室，也可以添加聊天室，加入或离开聊天室，以及列出可用的聊天室。
  
* 将所有这些都转换成为一个[MUD](https://en.wikipedia.org/wiki/MUD)。这些足够使你忙起来了！

## 一些建议
这里有一些可能会有所帮助的建议。

  * 让服务器程序使用它传递给`select()`的已连接套接字集作为已连接的每个客户端的标准列表。
  
    如果一个客户端断开，将其从该集合中删除。

    如果一个客户端连接上服务器端，将其加入到该列表。

    这个集合将始终反映在这个时间连接的所有人。

  * 在服务器上为每个连接设置一个缓冲区。还记得我们在早期的项目中，我们学习了如何使用缓冲区来积累数据，直到得到一个完整的数据包吗? _每个连接_ 都需要一个这样的缓冲区。在这个项目中，程序会有很多连接。
  
  * 还记得我们编写代码从字节串缓冲区提取数据包的项目吗?可以复用其中的策略。
  
  * 你需要用到`.to_bytes()` 和`.from_bytes()`来获取和设置数据包长度。

  * 从前面的项目中尽可能多的复用相关知识和模块。

<!-- 计分表
每项5分

客户端程序发送了正确的JSON `chat`数据包（不含昵称）

客户端程序发送了正确的JSON `hello`数据包

客户端程序正确处理的了JSON `join`数据包

客户端程序正确处理的了JSON `leave`数据包

客户端使用`chatui`实现了文本用户界面

客户端程序使用了多线程，一个线程用来接收消息，另一个线程为了处理输入和发送消息

客户端程序正确提取了长度和JSON数据包

客户端发送的JSON字符串用了UTF-8编码

客户端程序根据长度正确编码了JSON负载

客户端程序在启动命令行正确处理了昵称，服务器和端口号参数

客户端程序正确实现了`/q`命令

服务器端程序发送了正确的JSON `chat`数据包

服务器端程序发送了正确的JSON `join`数据包

服务器端程序发送了正确的JSON `leave`数据包

服务器程序正确处理的了JSON `hello`数据包

服务器端程序使用select处理了多个连接

服务器端程序从数据流中正确的解析除了长度和JSON数据包

服务器端的JSON字符串是UTF-8编码的

服务器端程序根据长度正确编码了JSON负载

服务器程序在启动命令行正确处理了端口号参数
-->
